(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var strip = require('strip-markdown');
var remark = require('remark');

var processor = remark().use(strip);

var $input = document.querySelector('[autofocus]');
var $output = document.querySelector('[readonly]');

$input.addEventListener('input', oninputchange);

oninputchange();

/* Handlers. */
function oninputchange() {
  $output.textContent = processor.processSync($input.value).toString();
}

},{"remark":120,"strip-markdown":126}],2:[function(require,module,exports){
'use strict';

module.exports = iterate;

var own = {}.hasOwnProperty;

function iterate(values, callback, context) {
  var index = -1;
  var result;

  if (!values) {
    throw new Error('Iterate requires that |this| not be ' + values);
  }

  if (!own.call(values, 'length')) {
    throw new Error('Iterate requires that |this| has a `length`');
  }

  if (typeof callback !== 'function') {
    throw new Error('`callback` must be a function');
  }

  /* The length might change, so we do not cache it. */
  while (++index < values.length) {
    /* Skip missing values. */
    if (!(index in values)) {
      continue;
    }

    result = callback.call(context, values[index], index, values);

    /* If `callback` returns a `number`, move `index` over to
     * `number`. */
    if (typeof result === 'number') {
      /* Make sure that negative numbers do not break the loop. */
      if (result < 0) {
        index = 0;
      }

      index = result - 1;
    }
  }
}

},{}],3:[function(require,module,exports){
'use strict';

module.exports = bail;

function bail(err) {
  if (err) {
    throw err;
  }
}

},{}],4:[function(require,module,exports){
'use strict';

module.exports = ccount;

function ccount(value, character) {
  var count = 0;
  var index;

  value = String(value);

  if (typeof character !== 'string' || character.length !== 1) {
    throw new Error('Expected character');
  }

  index = value.indexOf(character);

  while (index !== -1) {
    count++;
    index = value.indexOf(character, index + 1);
  }

  return count;
}

},{}],5:[function(require,module,exports){
module.exports={
  "nbsp": "¬†",
  "iexcl": "¬°",
  "cent": "¬¢",
  "pound": "¬£",
  "curren": "¬§",
  "yen": "¬•",
  "brvbar": "¬¶",
  "sect": "¬ß",
  "uml": "¬®",
  "copy": "¬©",
  "ordf": "¬™",
  "laquo": "¬´",
  "not": "¬¨",
  "shy": "¬≠",
  "reg": "¬Æ",
  "macr": "¬Ø",
  "deg": "¬∞",
  "plusmn": "¬±",
  "sup2": "¬≤",
  "sup3": "¬≥",
  "acute": "¬¥",
  "micro": "¬µ",
  "para": "¬∂",
  "middot": "¬∑",
  "cedil": "¬∏",
  "sup1": "¬π",
  "ordm": "¬∫",
  "raquo": "¬ª",
  "frac14": "¬º",
  "frac12": "¬Ω",
  "frac34": "¬æ",
  "iquest": "¬ø",
  "Agrave": "√Ä",
  "Aacute": "√Å",
  "Acirc": "√Ç",
  "Atilde": "√É",
  "Auml": "√Ñ",
  "Aring": "√Ö",
  "AElig": "√Ü",
  "Ccedil": "√á",
  "Egrave": "√à",
  "Eacute": "√â",
  "Ecirc": "√ä",
  "Euml": "√ã",
  "Igrave": "√å",
  "Iacute": "√ç",
  "Icirc": "√é",
  "Iuml": "√è",
  "ETH": "√ê",
  "Ntilde": "√ë",
  "Ograve": "√í",
  "Oacute": "√ì",
  "Ocirc": "√î",
  "Otilde": "√ï",
  "Ouml": "√ñ",
  "times": "√ó",
  "Oslash": "√ò",
  "Ugrave": "√ô",
  "Uacute": "√ö",
  "Ucirc": "√õ",
  "Uuml": "√ú",
  "Yacute": "√ù",
  "THORN": "√û",
  "szlig": "√ü",
  "agrave": "√†",
  "aacute": "√°",
  "acirc": "√¢",
  "atilde": "√£",
  "auml": "√§",
  "aring": "√•",
  "aelig": "√¶",
  "ccedil": "√ß",
  "egrave": "√®",
  "eacute": "√©",
  "ecirc": "√™",
  "euml": "√´",
  "igrave": "√¨",
  "iacute": "√≠",
  "icirc": "√Æ",
  "iuml": "√Ø",
  "eth": "√∞",
  "ntilde": "√±",
  "ograve": "√≤",
  "oacute": "√≥",
  "ocirc": "√¥",
  "otilde": "√µ",
  "ouml": "√∂",
  "divide": "√∑",
  "oslash": "√∏",
  "ugrave": "√π",
  "uacute": "√∫",
  "ucirc": "√ª",
  "uuml": "√º",
  "yacute": "√Ω",
  "thorn": "√æ",
  "yuml": "√ø",
  "fnof": "∆í",
  "Alpha": "Œë",
  "Beta": "Œí",
  "Gamma": "Œì",
  "Delta": "Œî",
  "Epsilon": "Œï",
  "Zeta": "Œñ",
  "Eta": "Œó",
  "Theta": "Œò",
  "Iota": "Œô",
  "Kappa": "Œö",
  "Lambda": "Œõ",
  "Mu": "Œú",
  "Nu": "Œù",
  "Xi": "Œû",
  "Omicron": "Œü",
  "Pi": "Œ†",
  "Rho": "Œ°",
  "Sigma": "Œ£",
  "Tau": "Œ§",
  "Upsilon": "Œ•",
  "Phi": "Œ¶",
  "Chi": "Œß",
  "Psi": "Œ®",
  "Omega": "Œ©",
  "alpha": "Œ±",
  "beta": "Œ≤",
  "gamma": "Œ≥",
  "delta": "Œ¥",
  "epsilon": "Œµ",
  "zeta": "Œ∂",
  "eta": "Œ∑",
  "theta": "Œ∏",
  "iota": "Œπ",
  "kappa": "Œ∫",
  "lambda": "Œª",
  "mu": "Œº",
  "nu": "ŒΩ",
  "xi": "Œæ",
  "omicron": "Œø",
  "pi": "œÄ",
  "rho": "œÅ",
  "sigmaf": "œÇ",
  "sigma": "œÉ",
  "tau": "œÑ",
  "upsilon": "œÖ",
  "phi": "œÜ",
  "chi": "œá",
  "psi": "œà",
  "omega": "œâ",
  "thetasym": "œë",
  "upsih": "œí",
  "piv": "œñ",
  "bull": "‚Ä¢",
  "hellip": "‚Ä¶",
  "prime": "‚Ä≤",
  "Prime": "‚Ä≥",
  "oline": "‚Äæ",
  "frasl": "‚ÅÑ",
  "weierp": "‚Ñò",
  "image": "‚Ñë",
  "real": "‚Ñú",
  "trade": "‚Ñ¢",
  "alefsym": "‚Ñµ",
  "larr": "‚Üê",
  "uarr": "‚Üë",
  "rarr": "‚Üí",
  "darr": "‚Üì",
  "harr": "‚Üî",
  "crarr": "‚Üµ",
  "lArr": "‚áê",
  "uArr": "‚áë",
  "rArr": "‚áí",
  "dArr": "‚áì",
  "hArr": "‚áî",
  "forall": "‚àÄ",
  "part": "‚àÇ",
  "exist": "‚àÉ",
  "empty": "‚àÖ",
  "nabla": "‚àá",
  "isin": "‚àà",
  "notin": "‚àâ",
  "ni": "‚àã",
  "prod": "‚àè",
  "sum": "‚àë",
  "minus": "‚àí",
  "lowast": "‚àó",
  "radic": "‚àö",
  "prop": "‚àù",
  "infin": "‚àû",
  "ang": "‚à†",
  "and": "‚àß",
  "or": "‚à®",
  "cap": "‚à©",
  "cup": "‚à™",
  "int": "‚à´",
  "there4": "‚à¥",
  "sim": "‚àº",
  "cong": "‚âÖ",
  "asymp": "‚âà",
  "ne": "‚â†",
  "equiv": "‚â°",
  "le": "‚â§",
  "ge": "‚â•",
  "sub": "‚äÇ",
  "sup": "‚äÉ",
  "nsub": "‚äÑ",
  "sube": "‚äÜ",
  "supe": "‚äá",
  "oplus": "‚äï",
  "otimes": "‚äó",
  "perp": "‚ä•",
  "sdot": "‚ãÖ",
  "lceil": "‚åà",
  "rceil": "‚åâ",
  "lfloor": "‚åä",
  "rfloor": "‚åã",
  "lang": "‚å©",
  "rang": "‚å™",
  "loz": "‚óä",
  "spades": "‚ô†",
  "clubs": "‚ô£",
  "hearts": "‚ô•",
  "diams": "‚ô¶",
  "quot": "\"",
  "amp": "&",
  "lt": "<",
  "gt": ">",
  "OElig": "≈í",
  "oelig": "≈ì",
  "Scaron": "≈†",
  "scaron": "≈°",
  "Yuml": "≈∏",
  "circ": "ÀÜ",
  "tilde": "Àú",
  "ensp": "‚ÄÇ",
  "emsp": "‚ÄÉ",
  "thinsp": "‚Äâ",
  "zwnj": "‚Äå",
  "zwj": "‚Äç",
  "lrm": "‚Äé",
  "rlm": "‚Äè",
  "ndash": "‚Äì",
  "mdash": "‚Äî",
  "lsquo": "‚Äò",
  "rsquo": "‚Äô",
  "sbquo": "‚Äö",
  "ldquo": "‚Äú",
  "rdquo": "‚Äù",
  "bdquo": "‚Äû",
  "dagger": "‚Ä†",
  "Dagger": "‚Ä°",
  "permil": "‚Ä∞",
  "lsaquo": "‚Äπ",
  "rsaquo": "‚Ä∫",
  "euro": "‚Ç¨"
}

},{}],6:[function(require,module,exports){
module.exports={
  "AElig": "√Ü",
  "AMP": "&",
  "Aacute": "√Å",
  "Acirc": "√Ç",
  "Agrave": "√Ä",
  "Aring": "√Ö",
  "Atilde": "√É",
  "Auml": "√Ñ",
  "COPY": "¬©",
  "Ccedil": "√á",
  "ETH": "√ê",
  "Eacute": "√â",
  "Ecirc": "√ä",
  "Egrave": "√à",
  "Euml": "√ã",
  "GT": ">",
  "Iacute": "√ç",
  "Icirc": "√é",
  "Igrave": "√å",
  "Iuml": "√è",
  "LT": "<",
  "Ntilde": "√ë",
  "Oacute": "√ì",
  "Ocirc": "√î",
  "Ograve": "√í",
  "Oslash": "√ò",
  "Otilde": "√ï",
  "Ouml": "√ñ",
  "QUOT": "\"",
  "REG": "¬Æ",
  "THORN": "√û",
  "Uacute": "√ö",
  "Ucirc": "√õ",
  "Ugrave": "√ô",
  "Uuml": "√ú",
  "Yacute": "√ù",
  "aacute": "√°",
  "acirc": "√¢",
  "acute": "¬¥",
  "aelig": "√¶",
  "agrave": "√†",
  "amp": "&",
  "aring": "√•",
  "atilde": "√£",
  "auml": "√§",
  "brvbar": "¬¶",
  "ccedil": "√ß",
  "cedil": "¬∏",
  "cent": "¬¢",
  "copy": "¬©",
  "curren": "¬§",
  "deg": "¬∞",
  "divide": "√∑",
  "eacute": "√©",
  "ecirc": "√™",
  "egrave": "√®",
  "eth": "√∞",
  "euml": "√´",
  "frac12": "¬Ω",
  "frac14": "¬º",
  "frac34": "¬æ",
  "gt": ">",
  "iacute": "√≠",
  "icirc": "√Æ",
  "iexcl": "¬°",
  "igrave": "√¨",
  "iquest": "¬ø",
  "iuml": "√Ø",
  "laquo": "¬´",
  "lt": "<",
  "macr": "¬Ø",
  "micro": "¬µ",
  "middot": "¬∑",
  "nbsp": "¬†",
  "not": "¬¨",
  "ntilde": "√±",
  "oacute": "√≥",
  "ocirc": "√¥",
  "ograve": "√≤",
  "ordf": "¬™",
  "ordm": "¬∫",
  "oslash": "√∏",
  "otilde": "√µ",
  "ouml": "√∂",
  "para": "¬∂",
  "plusmn": "¬±",
  "pound": "¬£",
  "quot": "\"",
  "raquo": "¬ª",
  "reg": "¬Æ",
  "sect": "¬ß",
  "shy": "¬≠",
  "sup1": "¬π",
  "sup2": "¬≤",
  "sup3": "¬≥",
  "szlig": "√ü",
  "thorn": "√æ",
  "times": "√ó",
  "uacute": "√∫",
  "ucirc": "√ª",
  "ugrave": "√π",
  "uml": "¬®",
  "uuml": "√º",
  "yacute": "√Ω",
  "yen": "¬•",
  "yuml": "√ø"
}

},{}],7:[function(require,module,exports){
module.exports={
  "AEli": "√Ü",
  "AElig": "√Ü",
  "AM": "&",
  "AMP": "&",
  "Aacut": "√Å",
  "Aacute": "√Å",
  "Abreve": "ƒÇ",
  "Acir": "√Ç",
  "Acirc": "√Ç",
  "Acy": "–ê",
  "Afr": "ùîÑ",
  "Agrav": "√Ä",
  "Agrave": "√Ä",
  "Alpha": "Œë",
  "Amacr": "ƒÄ",
  "And": "‚©ì",
  "Aogon": "ƒÑ",
  "Aopf": "ùî∏",
  "ApplyFunction": "‚Å°",
  "Arin": "√Ö",
  "Aring": "√Ö",
  "Ascr": "ùíú",
  "Assign": "‚âî",
  "Atild": "√É",
  "Atilde": "√É",
  "Aum": "√Ñ",
  "Auml": "√Ñ",
  "Backslash": "‚àñ",
  "Barv": "‚´ß",
  "Barwed": "‚åÜ",
  "Bcy": "–ë",
  "Because": "‚àµ",
  "Bernoullis": "‚Ñ¨",
  "Beta": "Œí",
  "Bfr": "ùîÖ",
  "Bopf": "ùîπ",
  "Breve": "Àò",
  "Bscr": "‚Ñ¨",
  "Bumpeq": "‚âé",
  "CHcy": "–ß",
  "COP": "¬©",
  "COPY": "¬©",
  "Cacute": "ƒÜ",
  "Cap": "‚ãí",
  "CapitalDifferentialD": "‚ÖÖ",
  "Cayleys": "‚Ñ≠",
  "Ccaron": "ƒå",
  "Ccedi": "√á",
  "Ccedil": "√á",
  "Ccirc": "ƒà",
  "Cconint": "‚à∞",
  "Cdot": "ƒä",
  "Cedilla": "¬∏",
  "CenterDot": "¬∑",
  "Cfr": "‚Ñ≠",
  "Chi": "Œß",
  "CircleDot": "‚äô",
  "CircleMinus": "‚äñ",
  "CirclePlus": "‚äï",
  "CircleTimes": "‚äó",
  "ClockwiseContourIntegral": "‚à≤",
  "CloseCurlyDoubleQuote": "‚Äù",
  "CloseCurlyQuote": "‚Äô",
  "Colon": "‚à∑",
  "Colone": "‚©¥",
  "Congruent": "‚â°",
  "Conint": "‚àØ",
  "ContourIntegral": "‚àÆ",
  "Copf": "‚ÑÇ",
  "Coproduct": "‚àê",
  "CounterClockwiseContourIntegral": "‚à≥",
  "Cross": "‚®Ø",
  "Cscr": "ùíû",
  "Cup": "‚ãì",
  "CupCap": "‚âç",
  "DD": "‚ÖÖ",
  "DDotrahd": "‚§ë",
  "DJcy": "–Ç",
  "DScy": "–Ö",
  "DZcy": "–è",
  "Dagger": "‚Ä°",
  "Darr": "‚Ü°",
  "Dashv": "‚´§",
  "Dcaron": "ƒé",
  "Dcy": "–î",
  "Del": "‚àá",
  "Delta": "Œî",
  "Dfr": "ùîá",
  "DiacriticalAcute": "¬¥",
  "DiacriticalDot": "Àô",
  "DiacriticalDoubleAcute": "Àù",
  "DiacriticalGrave": "`",
  "DiacriticalTilde": "Àú",
  "Diamond": "‚ãÑ",
  "DifferentialD": "‚ÖÜ",
  "Dopf": "ùîª",
  "Dot": "¬®",
  "DotDot": "‚Éú",
  "DotEqual": "‚âê",
  "DoubleContourIntegral": "‚àØ",
  "DoubleDot": "¬®",
  "DoubleDownArrow": "‚áì",
  "DoubleLeftArrow": "‚áê",
  "DoubleLeftRightArrow": "‚áî",
  "DoubleLeftTee": "‚´§",
  "DoubleLongLeftArrow": "‚ü∏",
  "DoubleLongLeftRightArrow": "‚ü∫",
  "DoubleLongRightArrow": "‚üπ",
  "DoubleRightArrow": "‚áí",
  "DoubleRightTee": "‚ä®",
  "DoubleUpArrow": "‚áë",
  "DoubleUpDownArrow": "‚áï",
  "DoubleVerticalBar": "‚à•",
  "DownArrow": "‚Üì",
  "DownArrowBar": "‚§ì",
  "DownArrowUpArrow": "‚áµ",
  "DownBreve": "Ãë",
  "DownLeftRightVector": "‚•ê",
  "DownLeftTeeVector": "‚•û",
  "DownLeftVector": "‚ÜΩ",
  "DownLeftVectorBar": "‚•ñ",
  "DownRightTeeVector": "‚•ü",
  "DownRightVector": "‚áÅ",
  "DownRightVectorBar": "‚•ó",
  "DownTee": "‚ä§",
  "DownTeeArrow": "‚Üß",
  "Downarrow": "‚áì",
  "Dscr": "ùíü",
  "Dstrok": "ƒê",
  "ENG": "≈ä",
  "ET": "√ê",
  "ETH": "√ê",
  "Eacut": "√â",
  "Eacute": "√â",
  "Ecaron": "ƒö",
  "Ecir": "√ä",
  "Ecirc": "√ä",
  "Ecy": "–≠",
  "Edot": "ƒñ",
  "Efr": "ùîà",
  "Egrav": "√à",
  "Egrave": "√à",
  "Element": "‚àà",
  "Emacr": "ƒí",
  "EmptySmallSquare": "‚óª",
  "EmptyVerySmallSquare": "‚ñ´",
  "Eogon": "ƒò",
  "Eopf": "ùîº",
  "Epsilon": "Œï",
  "Equal": "‚©µ",
  "EqualTilde": "‚âÇ",
  "Equilibrium": "‚áå",
  "Escr": "‚Ñ∞",
  "Esim": "‚©≥",
  "Eta": "Œó",
  "Eum": "√ã",
  "Euml": "√ã",
  "Exists": "‚àÉ",
  "ExponentialE": "‚Öá",
  "Fcy": "–§",
  "Ffr": "ùîâ",
  "FilledSmallSquare": "‚óº",
  "FilledVerySmallSquare": "‚ñ™",
  "Fopf": "ùîΩ",
  "ForAll": "‚àÄ",
  "Fouriertrf": "‚Ñ±",
  "Fscr": "‚Ñ±",
  "GJcy": "–É",
  "G": ">",
  "GT": ">",
  "Gamma": "Œì",
  "Gammad": "œú",
  "Gbreve": "ƒû",
  "Gcedil": "ƒ¢",
  "Gcirc": "ƒú",
  "Gcy": "–ì",
  "Gdot": "ƒ†",
  "Gfr": "ùîä",
  "Gg": "‚ãô",
  "Gopf": "ùîæ",
  "GreaterEqual": "‚â•",
  "GreaterEqualLess": "‚ãõ",
  "GreaterFullEqual": "‚âß",
  "GreaterGreater": "‚™¢",
  "GreaterLess": "‚â∑",
  "GreaterSlantEqual": "‚©æ",
  "GreaterTilde": "‚â≥",
  "Gscr": "ùí¢",
  "Gt": "‚â´",
  "HARDcy": "–™",
  "Hacek": "Àá",
  "Hat": "^",
  "Hcirc": "ƒ§",
  "Hfr": "‚Ñå",
  "HilbertSpace": "‚Ñã",
  "Hopf": "‚Ñç",
  "HorizontalLine": "‚îÄ",
  "Hscr": "‚Ñã",
  "Hstrok": "ƒ¶",
  "HumpDownHump": "‚âé",
  "HumpEqual": "‚âè",
  "IEcy": "–ï",
  "IJlig": "ƒ≤",
  "IOcy": "–Å",
  "Iacut": "√ç",
  "Iacute": "√ç",
  "Icir": "√é",
  "Icirc": "√é",
  "Icy": "–ò",
  "Idot": "ƒ∞",
  "Ifr": "‚Ñë",
  "Igrav": "√å",
  "Igrave": "√å",
  "Im": "‚Ñë",
  "Imacr": "ƒ™",
  "ImaginaryI": "‚Öà",
  "Implies": "‚áí",
  "Int": "‚à¨",
  "Integral": "‚à´",
  "Intersection": "‚ãÇ",
  "InvisibleComma": "‚Å£",
  "InvisibleTimes": "‚Å¢",
  "Iogon": "ƒÆ",
  "Iopf": "ùïÄ",
  "Iota": "Œô",
  "Iscr": "‚Ñê",
  "Itilde": "ƒ®",
  "Iukcy": "–Ü",
  "Ium": "√è",
  "Iuml": "√è",
  "Jcirc": "ƒ¥",
  "Jcy": "–ô",
  "Jfr": "ùîç",
  "Jopf": "ùïÅ",
  "Jscr": "ùí•",
  "Jsercy": "–à",
  "Jukcy": "–Ñ",
  "KHcy": "–•",
  "KJcy": "–å",
  "Kappa": "Œö",
  "Kcedil": "ƒ∂",
  "Kcy": "–ö",
  "Kfr": "ùîé",
  "Kopf": "ùïÇ",
  "Kscr": "ùí¶",
  "LJcy": "–â",
  "L": "<",
  "LT": "<",
  "Lacute": "ƒπ",
  "Lambda": "Œõ",
  "Lang": "‚ü™",
  "Laplacetrf": "‚Ñí",
  "Larr": "‚Üû",
  "Lcaron": "ƒΩ",
  "Lcedil": "ƒª",
  "Lcy": "–õ",
  "LeftAngleBracket": "‚ü®",
  "LeftArrow": "‚Üê",
  "LeftArrowBar": "‚á§",
  "LeftArrowRightArrow": "‚áÜ",
  "LeftCeiling": "‚åà",
  "LeftDoubleBracket": "‚ü¶",
  "LeftDownTeeVector": "‚•°",
  "LeftDownVector": "‚áÉ",
  "LeftDownVectorBar": "‚•ô",
  "LeftFloor": "‚åä",
  "LeftRightArrow": "‚Üî",
  "LeftRightVector": "‚•é",
  "LeftTee": "‚ä£",
  "LeftTeeArrow": "‚Ü§",
  "LeftTeeVector": "‚•ö",
  "LeftTriangle": "‚ä≤",
  "LeftTriangleBar": "‚ßè",
  "LeftTriangleEqual": "‚ä¥",
  "LeftUpDownVector": "‚•ë",
  "LeftUpTeeVector": "‚•†",
  "LeftUpVector": "‚Üø",
  "LeftUpVectorBar": "‚•ò",
  "LeftVector": "‚Üº",
  "LeftVectorBar": "‚•í",
  "Leftarrow": "‚áê",
  "Leftrightarrow": "‚áî",
  "LessEqualGreater": "‚ãö",
  "LessFullEqual": "‚â¶",
  "LessGreater": "‚â∂",
  "LessLess": "‚™°",
  "LessSlantEqual": "‚©Ω",
  "LessTilde": "‚â≤",
  "Lfr": "ùîè",
  "Ll": "‚ãò",
  "Lleftarrow": "‚áö",
  "Lmidot": "ƒø",
  "LongLeftArrow": "‚üµ",
  "LongLeftRightArrow": "‚ü∑",
  "LongRightArrow": "‚ü∂",
  "Longleftarrow": "‚ü∏",
  "Longleftrightarrow": "‚ü∫",
  "Longrightarrow": "‚üπ",
  "Lopf": "ùïÉ",
  "LowerLeftArrow": "‚Üô",
  "LowerRightArrow": "‚Üò",
  "Lscr": "‚Ñí",
  "Lsh": "‚Ü∞",
  "Lstrok": "≈Å",
  "Lt": "‚â™",
  "Map": "‚§Ö",
  "Mcy": "–ú",
  "MediumSpace": "‚Åü",
  "Mellintrf": "‚Ñ≥",
  "Mfr": "ùîê",
  "MinusPlus": "‚àì",
  "Mopf": "ùïÑ",
  "Mscr": "‚Ñ≥",
  "Mu": "Œú",
  "NJcy": "–ä",
  "Nacute": "≈É",
  "Ncaron": "≈á",
  "Ncedil": "≈Ö",
  "Ncy": "–ù",
  "NegativeMediumSpace": "‚Äã",
  "NegativeThickSpace": "‚Äã",
  "NegativeThinSpace": "‚Äã",
  "NegativeVeryThinSpace": "‚Äã",
  "NestedGreaterGreater": "‚â´",
  "NestedLessLess": "‚â™",
  "NewLine": "\n",
  "Nfr": "ùîë",
  "NoBreak": "‚Å†",
  "NonBreakingSpace": "¬†",
  "Nopf": "‚Ñï",
  "Not": "‚´¨",
  "NotCongruent": "‚â¢",
  "NotCupCap": "‚â≠",
  "NotDoubleVerticalBar": "‚à¶",
  "NotElement": "‚àâ",
  "NotEqual": "‚â†",
  "NotEqualTilde": "‚âÇÃ∏",
  "NotExists": "‚àÑ",
  "NotGreater": "‚âØ",
  "NotGreaterEqual": "‚â±",
  "NotGreaterFullEqual": "‚âßÃ∏",
  "NotGreaterGreater": "‚â´Ã∏",
  "NotGreaterLess": "‚âπ",
  "NotGreaterSlantEqual": "‚©æÃ∏",
  "NotGreaterTilde": "‚âµ",
  "NotHumpDownHump": "‚âéÃ∏",
  "NotHumpEqual": "‚âèÃ∏",
  "NotLeftTriangle": "‚ã™",
  "NotLeftTriangleBar": "‚ßèÃ∏",
  "NotLeftTriangleEqual": "‚ã¨",
  "NotLess": "‚âÆ",
  "NotLessEqual": "‚â∞",
  "NotLessGreater": "‚â∏",
  "NotLessLess": "‚â™Ã∏",
  "NotLessSlantEqual": "‚©ΩÃ∏",
  "NotLessTilde": "‚â¥",
  "NotNestedGreaterGreater": "‚™¢Ã∏",
  "NotNestedLessLess": "‚™°Ã∏",
  "NotPrecedes": "‚äÄ",
  "NotPrecedesEqual": "‚™ØÃ∏",
  "NotPrecedesSlantEqual": "‚ã†",
  "NotReverseElement": "‚àå",
  "NotRightTriangle": "‚ã´",
  "NotRightTriangleBar": "‚ßêÃ∏",
  "NotRightTriangleEqual": "‚ã≠",
  "NotSquareSubset": "‚äèÃ∏",
  "NotSquareSubsetEqual": "‚ã¢",
  "NotSquareSuperset": "‚äêÃ∏",
  "NotSquareSupersetEqual": "‚ã£",
  "NotSubset": "‚äÇ‚Éí",
  "NotSubsetEqual": "‚äà",
  "NotSucceeds": "‚äÅ",
  "NotSucceedsEqual": "‚™∞Ã∏",
  "NotSucceedsSlantEqual": "‚ã°",
  "NotSucceedsTilde": "‚âøÃ∏",
  "NotSuperset": "‚äÉ‚Éí",
  "NotSupersetEqual": "‚äâ",
  "NotTilde": "‚âÅ",
  "NotTildeEqual": "‚âÑ",
  "NotTildeFullEqual": "‚âá",
  "NotTildeTilde": "‚ââ",
  "NotVerticalBar": "‚à§",
  "Nscr": "ùí©",
  "Ntild": "√ë",
  "Ntilde": "√ë",
  "Nu": "Œù",
  "OElig": "≈í",
  "Oacut": "√ì",
  "Oacute": "√ì",
  "Ocir": "√î",
  "Ocirc": "√î",
  "Ocy": "–û",
  "Odblac": "≈ê",
  "Ofr": "ùîí",
  "Ograv": "√í",
  "Ograve": "√í",
  "Omacr": "≈å",
  "Omega": "Œ©",
  "Omicron": "Œü",
  "Oopf": "ùïÜ",
  "OpenCurlyDoubleQuote": "‚Äú",
  "OpenCurlyQuote": "‚Äò",
  "Or": "‚©î",
  "Oscr": "ùí™",
  "Oslas": "√ò",
  "Oslash": "√ò",
  "Otild": "√ï",
  "Otilde": "√ï",
  "Otimes": "‚®∑",
  "Oum": "√ñ",
  "Ouml": "√ñ",
  "OverBar": "‚Äæ",
  "OverBrace": "‚èû",
  "OverBracket": "‚é¥",
  "OverParenthesis": "‚èú",
  "PartialD": "‚àÇ",
  "Pcy": "–ü",
  "Pfr": "ùîì",
  "Phi": "Œ¶",
  "Pi": "Œ†",
  "PlusMinus": "¬±",
  "Poincareplane": "‚Ñå",
  "Popf": "‚Ñô",
  "Pr": "‚™ª",
  "Precedes": "‚â∫",
  "PrecedesEqual": "‚™Ø",
  "PrecedesSlantEqual": "‚âº",
  "PrecedesTilde": "‚âæ",
  "Prime": "‚Ä≥",
  "Product": "‚àè",
  "Proportion": "‚à∑",
  "Proportional": "‚àù",
  "Pscr": "ùí´",
  "Psi": "Œ®",
  "QUO": "\"",
  "QUOT": "\"",
  "Qfr": "ùîî",
  "Qopf": "‚Ñö",
  "Qscr": "ùí¨",
  "RBarr": "‚§ê",
  "RE": "¬Æ",
  "REG": "¬Æ",
  "Racute": "≈î",
  "Rang": "‚ü´",
  "Rarr": "‚Ü†",
  "Rarrtl": "‚§ñ",
  "Rcaron": "≈ò",
  "Rcedil": "≈ñ",
  "Rcy": "–†",
  "Re": "‚Ñú",
  "ReverseElement": "‚àã",
  "ReverseEquilibrium": "‚áã",
  "ReverseUpEquilibrium": "‚•Ø",
  "Rfr": "‚Ñú",
  "Rho": "Œ°",
  "RightAngleBracket": "‚ü©",
  "RightArrow": "‚Üí",
  "RightArrowBar": "‚á•",
  "RightArrowLeftArrow": "‚áÑ",
  "RightCeiling": "‚åâ",
  "RightDoubleBracket": "‚üß",
  "RightDownTeeVector": "‚•ù",
  "RightDownVector": "‚áÇ",
  "RightDownVectorBar": "‚•ï",
  "RightFloor": "‚åã",
  "RightTee": "‚ä¢",
  "RightTeeArrow": "‚Ü¶",
  "RightTeeVector": "‚•õ",
  "RightTriangle": "‚ä≥",
  "RightTriangleBar": "‚ßê",
  "RightTriangleEqual": "‚äµ",
  "RightUpDownVector": "‚•è",
  "RightUpTeeVector": "‚•ú",
  "RightUpVector": "‚Üæ",
  "RightUpVectorBar": "‚•î",
  "RightVector": "‚áÄ",
  "RightVectorBar": "‚•ì",
  "Rightarrow": "‚áí",
  "Ropf": "‚Ñù",
  "RoundImplies": "‚•∞",
  "Rrightarrow": "‚áõ",
  "Rscr": "‚Ñõ",
  "Rsh": "‚Ü±",
  "RuleDelayed": "‚ß¥",
  "SHCHcy": "–©",
  "SHcy": "–®",
  "SOFTcy": "–¨",
  "Sacute": "≈ö",
  "Sc": "‚™º",
  "Scaron": "≈†",
  "Scedil": "≈û",
  "Scirc": "≈ú",
  "Scy": "–°",
  "Sfr": "ùîñ",
  "ShortDownArrow": "‚Üì",
  "ShortLeftArrow": "‚Üê",
  "ShortRightArrow": "‚Üí",
  "ShortUpArrow": "‚Üë",
  "Sigma": "Œ£",
  "SmallCircle": "‚àò",
  "Sopf": "ùïä",
  "Sqrt": "‚àö",
  "Square": "‚ñ°",
  "SquareIntersection": "‚äì",
  "SquareSubset": "‚äè",
  "SquareSubsetEqual": "‚äë",
  "SquareSuperset": "‚äê",
  "SquareSupersetEqual": "‚äí",
  "SquareUnion": "‚äî",
  "Sscr": "ùíÆ",
  "Star": "‚ãÜ",
  "Sub": "‚ãê",
  "Subset": "‚ãê",
  "SubsetEqual": "‚äÜ",
  "Succeeds": "‚âª",
  "SucceedsEqual": "‚™∞",
  "SucceedsSlantEqual": "‚âΩ",
  "SucceedsTilde": "‚âø",
  "SuchThat": "‚àã",
  "Sum": "‚àë",
  "Sup": "‚ãë",
  "Superset": "‚äÉ",
  "SupersetEqual": "‚äá",
  "Supset": "‚ãë",
  "THOR": "√û",
  "THORN": "√û",
  "TRADE": "‚Ñ¢",
  "TSHcy": "–ã",
  "TScy": "–¶",
  "Tab": "\t",
  "Tau": "Œ§",
  "Tcaron": "≈§",
  "Tcedil": "≈¢",
  "Tcy": "–¢",
  "Tfr": "ùîó",
  "Therefore": "‚à¥",
  "Theta": "Œò",
  "ThickSpace": "‚Åü‚Ää",
  "ThinSpace": "‚Äâ",
  "Tilde": "‚àº",
  "TildeEqual": "‚âÉ",
  "TildeFullEqual": "‚âÖ",
  "TildeTilde": "‚âà",
  "Topf": "ùïã",
  "TripleDot": "‚Éõ",
  "Tscr": "ùíØ",
  "Tstrok": "≈¶",
  "Uacut": "√ö",
  "Uacute": "√ö",
  "Uarr": "‚Üü",
  "Uarrocir": "‚•â",
  "Ubrcy": "–é",
  "Ubreve": "≈¨",
  "Ucir": "√õ",
  "Ucirc": "√õ",
  "Ucy": "–£",
  "Udblac": "≈∞",
  "Ufr": "ùîò",
  "Ugrav": "√ô",
  "Ugrave": "√ô",
  "Umacr": "≈™",
  "UnderBar": "_",
  "UnderBrace": "‚èü",
  "UnderBracket": "‚éµ",
  "UnderParenthesis": "‚èù",
  "Union": "‚ãÉ",
  "UnionPlus": "‚äé",
  "Uogon": "≈≤",
  "Uopf": "ùïå",
  "UpArrow": "‚Üë",
  "UpArrowBar": "‚§í",
  "UpArrowDownArrow": "‚áÖ",
  "UpDownArrow": "‚Üï",
  "UpEquilibrium": "‚•Æ",
  "UpTee": "‚ä•",
  "UpTeeArrow": "‚Ü•",
  "Uparrow": "‚áë",
  "Updownarrow": "‚áï",
  "UpperLeftArrow": "‚Üñ",
  "UpperRightArrow": "‚Üó",
  "Upsi": "œí",
  "Upsilon": "Œ•",
  "Uring": "≈Æ",
  "Uscr": "ùí∞",
  "Utilde": "≈®",
  "Uum": "√ú",
  "Uuml": "√ú",
  "VDash": "‚ä´",
  "Vbar": "‚´´",
  "Vcy": "–í",
  "Vdash": "‚ä©",
  "Vdashl": "‚´¶",
  "Vee": "‚ãÅ",
  "Verbar": "‚Äñ",
  "Vert": "‚Äñ",
  "VerticalBar": "‚à£",
  "VerticalLine": "|",
  "VerticalSeparator": "‚ùò",
  "VerticalTilde": "‚âÄ",
  "VeryThinSpace": "‚Ää",
  "Vfr": "ùîô",
  "Vopf": "ùïç",
  "Vscr": "ùí±",
  "Vvdash": "‚ä™",
  "Wcirc": "≈¥",
  "Wedge": "‚ãÄ",
  "Wfr": "ùîö",
  "Wopf": "ùïé",
  "Wscr": "ùí≤",
  "Xfr": "ùîõ",
  "Xi": "Œû",
  "Xopf": "ùïè",
  "Xscr": "ùí≥",
  "YAcy": "–Ø",
  "YIcy": "–á",
  "YUcy": "–Æ",
  "Yacut": "√ù",
  "Yacute": "√ù",
  "Ycirc": "≈∂",
  "Ycy": "–´",
  "Yfr": "ùîú",
  "Yopf": "ùïê",
  "Yscr": "ùí¥",
  "Yuml": "≈∏",
  "ZHcy": "–ñ",
  "Zacute": "≈π",
  "Zcaron": "≈Ω",
  "Zcy": "–ó",
  "Zdot": "≈ª",
  "ZeroWidthSpace": "‚Äã",
  "Zeta": "Œñ",
  "Zfr": "‚Ñ®",
  "Zopf": "‚Ñ§",
  "Zscr": "ùíµ",
  "aacut": "√°",
  "aacute": "√°",
  "abreve": "ƒÉ",
  "ac": "‚àæ",
  "acE": "‚àæÃ≥",
  "acd": "‚àø",
  "acir": "√¢",
  "acirc": "√¢",
  "acut": "¬¥",
  "acute": "¬¥",
  "acy": "–∞",
  "aeli": "√¶",
  "aelig": "√¶",
  "af": "‚Å°",
  "afr": "ùîû",
  "agrav": "√†",
  "agrave": "√†",
  "alefsym": "‚Ñµ",
  "aleph": "‚Ñµ",
  "alpha": "Œ±",
  "amacr": "ƒÅ",
  "amalg": "‚®ø",
  "am": "&",
  "amp": "&",
  "and": "‚àß",
  "andand": "‚©ï",
  "andd": "‚©ú",
  "andslope": "‚©ò",
  "andv": "‚©ö",
  "ang": "‚à†",
  "ange": "‚¶§",
  "angle": "‚à†",
  "angmsd": "‚à°",
  "angmsdaa": "‚¶®",
  "angmsdab": "‚¶©",
  "angmsdac": "‚¶™",
  "angmsdad": "‚¶´",
  "angmsdae": "‚¶¨",
  "angmsdaf": "‚¶≠",
  "angmsdag": "‚¶Æ",
  "angmsdah": "‚¶Ø",
  "angrt": "‚àü",
  "angrtvb": "‚äæ",
  "angrtvbd": "‚¶ù",
  "angsph": "‚à¢",
  "angst": "√Ö",
  "angzarr": "‚çº",
  "aogon": "ƒÖ",
  "aopf": "ùïí",
  "ap": "‚âà",
  "apE": "‚©∞",
  "apacir": "‚©Ø",
  "ape": "‚âä",
  "apid": "‚âã",
  "apos": "'",
  "approx": "‚âà",
  "approxeq": "‚âä",
  "arin": "√•",
  "aring": "√•",
  "ascr": "ùí∂",
  "ast": "*",
  "asymp": "‚âà",
  "asympeq": "‚âç",
  "atild": "√£",
  "atilde": "√£",
  "aum": "√§",
  "auml": "√§",
  "awconint": "‚à≥",
  "awint": "‚®ë",
  "bNot": "‚´≠",
  "backcong": "‚âå",
  "backepsilon": "œ∂",
  "backprime": "‚Äµ",
  "backsim": "‚àΩ",
  "backsimeq": "‚ãç",
  "barvee": "‚äΩ",
  "barwed": "‚åÖ",
  "barwedge": "‚åÖ",
  "bbrk": "‚éµ",
  "bbrktbrk": "‚é∂",
  "bcong": "‚âå",
  "bcy": "–±",
  "bdquo": "‚Äû",
  "becaus": "‚àµ",
  "because": "‚àµ",
  "bemptyv": "‚¶∞",
  "bepsi": "œ∂",
  "bernou": "‚Ñ¨",
  "beta": "Œ≤",
  "beth": "‚Ñ∂",
  "between": "‚â¨",
  "bfr": "ùîü",
  "bigcap": "‚ãÇ",
  "bigcirc": "‚óØ",
  "bigcup": "‚ãÉ",
  "bigodot": "‚®Ä",
  "bigoplus": "‚®Å",
  "bigotimes": "‚®Ç",
  "bigsqcup": "‚®Ü",
  "bigstar": "‚òÖ",
  "bigtriangledown": "‚ñΩ",
  "bigtriangleup": "‚ñ≥",
  "biguplus": "‚®Ñ",
  "bigvee": "‚ãÅ",
  "bigwedge": "‚ãÄ",
  "bkarow": "‚§ç",
  "blacklozenge": "‚ß´",
  "blacksquare": "‚ñ™",
  "blacktriangle": "‚ñ¥",
  "blacktriangledown": "‚ñæ",
  "blacktriangleleft": "‚óÇ",
  "blacktriangleright": "‚ñ∏",
  "blank": "‚ê£",
  "blk12": "‚ñí",
  "blk14": "‚ñë",
  "blk34": "‚ñì",
  "block": "‚ñà",
  "bne": "=‚É•",
  "bnequiv": "‚â°‚É•",
  "bnot": "‚åê",
  "bopf": "ùïì",
  "bot": "‚ä•",
  "bottom": "‚ä•",
  "bowtie": "‚ãà",
  "boxDL": "‚ïó",
  "boxDR": "‚ïî",
  "boxDl": "‚ïñ",
  "boxDr": "‚ïì",
  "boxH": "‚ïê",
  "boxHD": "‚ï¶",
  "boxHU": "‚ï©",
  "boxHd": "‚ï§",
  "boxHu": "‚ïß",
  "boxUL": "‚ïù",
  "boxUR": "‚ïö",
  "boxUl": "‚ïú",
  "boxUr": "‚ïô",
  "boxV": "‚ïë",
  "boxVH": "‚ï¨",
  "boxVL": "‚ï£",
  "boxVR": "‚ï†",
  "boxVh": "‚ï´",
  "boxVl": "‚ï¢",
  "boxVr": "‚ïü",
  "boxbox": "‚ßâ",
  "boxdL": "‚ïï",
  "boxdR": "‚ïí",
  "boxdl": "‚îê",
  "boxdr": "‚îå",
  "boxh": "‚îÄ",
  "boxhD": "‚ï•",
  "boxhU": "‚ï®",
  "boxhd": "‚î¨",
  "boxhu": "‚î¥",
  "boxminus": "‚äü",
  "boxplus": "‚äû",
  "boxtimes": "‚ä†",
  "boxuL": "‚ïõ",
  "boxuR": "‚ïò",
  "boxul": "‚îò",
  "boxur": "‚îî",
  "boxv": "‚îÇ",
  "boxvH": "‚ï™",
  "boxvL": "‚ï°",
  "boxvR": "‚ïû",
  "boxvh": "‚îº",
  "boxvl": "‚î§",
  "boxvr": "‚îú",
  "bprime": "‚Äµ",
  "breve": "Àò",
  "brvba": "¬¶",
  "brvbar": "¬¶",
  "bscr": "ùí∑",
  "bsemi": "‚Åè",
  "bsim": "‚àΩ",
  "bsime": "‚ãç",
  "bsol": "\\",
  "bsolb": "‚ßÖ",
  "bsolhsub": "‚üà",
  "bull": "‚Ä¢",
  "bullet": "‚Ä¢",
  "bump": "‚âé",
  "bumpE": "‚™Æ",
  "bumpe": "‚âè",
  "bumpeq": "‚âè",
  "cacute": "ƒá",
  "cap": "‚à©",
  "capand": "‚©Ñ",
  "capbrcup": "‚©â",
  "capcap": "‚©ã",
  "capcup": "‚©á",
  "capdot": "‚©Ä",
  "caps": "‚à©Ô∏Ä",
  "caret": "‚ÅÅ",
  "caron": "Àá",
  "ccaps": "‚©ç",
  "ccaron": "ƒç",
  "ccedi": "√ß",
  "ccedil": "√ß",
  "ccirc": "ƒâ",
  "ccups": "‚©å",
  "ccupssm": "‚©ê",
  "cdot": "ƒã",
  "cedi": "¬∏",
  "cedil": "¬∏",
  "cemptyv": "‚¶≤",
  "cen": "¬¢",
  "cent": "¬¢",
  "centerdot": "¬∑",
  "cfr": "ùî†",
  "chcy": "—á",
  "check": "‚úì",
  "checkmark": "‚úì",
  "chi": "œá",
  "cir": "‚óã",
  "cirE": "‚ßÉ",
  "circ": "ÀÜ",
  "circeq": "‚âó",
  "circlearrowleft": "‚Ü∫",
  "circlearrowright": "‚Üª",
  "circledR": "¬Æ",
  "circledS": "‚ìà",
  "circledast": "‚äõ",
  "circledcirc": "‚äö",
  "circleddash": "‚äù",
  "cire": "‚âó",
  "cirfnint": "‚®ê",
  "cirmid": "‚´Ø",
  "cirscir": "‚ßÇ",
  "clubs": "‚ô£",
  "clubsuit": "‚ô£",
  "colon": ":",
  "colone": "‚âî",
  "coloneq": "‚âî",
  "comma": ",",
  "commat": "@",
  "comp": "‚àÅ",
  "compfn": "‚àò",
  "complement": "‚àÅ",
  "complexes": "‚ÑÇ",
  "cong": "‚âÖ",
  "congdot": "‚©≠",
  "conint": "‚àÆ",
  "copf": "ùïî",
  "coprod": "‚àê",
  "cop": "¬©",
  "copy": "¬©",
  "copysr": "‚Ñó",
  "crarr": "‚Üµ",
  "cross": "‚úó",
  "cscr": "ùí∏",
  "csub": "‚´è",
  "csube": "‚´ë",
  "csup": "‚´ê",
  "csupe": "‚´í",
  "ctdot": "‚ãØ",
  "cudarrl": "‚§∏",
  "cudarrr": "‚§µ",
  "cuepr": "‚ãû",
  "cuesc": "‚ãü",
  "cularr": "‚Ü∂",
  "cularrp": "‚§Ω",
  "cup": "‚à™",
  "cupbrcap": "‚©à",
  "cupcap": "‚©Ü",
  "cupcup": "‚©ä",
  "cupdot": "‚äç",
  "cupor": "‚©Ö",
  "cups": "‚à™Ô∏Ä",
  "curarr": "‚Ü∑",
  "curarrm": "‚§º",
  "curlyeqprec": "‚ãû",
  "curlyeqsucc": "‚ãü",
  "curlyvee": "‚ãé",
  "curlywedge": "‚ãè",
  "curre": "¬§",
  "curren": "¬§",
  "curvearrowleft": "‚Ü∂",
  "curvearrowright": "‚Ü∑",
  "cuvee": "‚ãé",
  "cuwed": "‚ãè",
  "cwconint": "‚à≤",
  "cwint": "‚à±",
  "cylcty": "‚å≠",
  "dArr": "‚áì",
  "dHar": "‚••",
  "dagger": "‚Ä†",
  "daleth": "‚Ñ∏",
  "darr": "‚Üì",
  "dash": "‚Äê",
  "dashv": "‚ä£",
  "dbkarow": "‚§è",
  "dblac": "Àù",
  "dcaron": "ƒè",
  "dcy": "–¥",
  "dd": "‚ÖÜ",
  "ddagger": "‚Ä°",
  "ddarr": "‚áä",
  "ddotseq": "‚©∑",
  "de": "¬∞",
  "deg": "¬∞",
  "delta": "Œ¥",
  "demptyv": "‚¶±",
  "dfisht": "‚•ø",
  "dfr": "ùî°",
  "dharl": "‚áÉ",
  "dharr": "‚áÇ",
  "diam": "‚ãÑ",
  "diamond": "‚ãÑ",
  "diamondsuit": "‚ô¶",
  "diams": "‚ô¶",
  "die": "¬®",
  "digamma": "œù",
  "disin": "‚ã≤",
  "div": "√∑",
  "divid": "√∑",
  "divide": "√∑",
  "divideontimes": "‚ãá",
  "divonx": "‚ãá",
  "djcy": "—í",
  "dlcorn": "‚åû",
  "dlcrop": "‚åç",
  "dollar": "$",
  "dopf": "ùïï",
  "dot": "Àô",
  "doteq": "‚âê",
  "doteqdot": "‚âë",
  "dotminus": "‚à∏",
  "dotplus": "‚àî",
  "dotsquare": "‚ä°",
  "doublebarwedge": "‚åÜ",
  "downarrow": "‚Üì",
  "downdownarrows": "‚áä",
  "downharpoonleft": "‚áÉ",
  "downharpoonright": "‚áÇ",
  "drbkarow": "‚§ê",
  "drcorn": "‚åü",
  "drcrop": "‚åå",
  "dscr": "ùíπ",
  "dscy": "—ï",
  "dsol": "‚ß∂",
  "dstrok": "ƒë",
  "dtdot": "‚ã±",
  "dtri": "‚ñø",
  "dtrif": "‚ñæ",
  "duarr": "‚áµ",
  "duhar": "‚•Ø",
  "dwangle": "‚¶¶",
  "dzcy": "—ü",
  "dzigrarr": "‚üø",
  "eDDot": "‚©∑",
  "eDot": "‚âë",
  "eacut": "√©",
  "eacute": "√©",
  "easter": "‚©Æ",
  "ecaron": "ƒõ",
  "ecir": "√™",
  "ecirc": "√™",
  "ecolon": "‚âï",
  "ecy": "—ç",
  "edot": "ƒó",
  "ee": "‚Öá",
  "efDot": "‚âí",
  "efr": "ùî¢",
  "eg": "‚™ö",
  "egrav": "√®",
  "egrave": "√®",
  "egs": "‚™ñ",
  "egsdot": "‚™ò",
  "el": "‚™ô",
  "elinters": "‚èß",
  "ell": "‚Ñì",
  "els": "‚™ï",
  "elsdot": "‚™ó",
  "emacr": "ƒì",
  "empty": "‚àÖ",
  "emptyset": "‚àÖ",
  "emptyv": "‚àÖ",
  "emsp13": "‚ÄÑ",
  "emsp14": "‚ÄÖ",
  "emsp": "‚ÄÉ",
  "eng": "≈ã",
  "ensp": "‚ÄÇ",
  "eogon": "ƒô",
  "eopf": "ùïñ",
  "epar": "‚ãï",
  "eparsl": "‚ß£",
  "eplus": "‚©±",
  "epsi": "Œµ",
  "epsilon": "Œµ",
  "epsiv": "œµ",
  "eqcirc": "‚âñ",
  "eqcolon": "‚âï",
  "eqsim": "‚âÇ",
  "eqslantgtr": "‚™ñ",
  "eqslantless": "‚™ï",
  "equals": "=",
  "equest": "‚âü",
  "equiv": "‚â°",
  "equivDD": "‚©∏",
  "eqvparsl": "‚ß•",
  "erDot": "‚âì",
  "erarr": "‚•±",
  "escr": "‚ÑØ",
  "esdot": "‚âê",
  "esim": "‚âÇ",
  "eta": "Œ∑",
  "et": "√∞",
  "eth": "√∞",
  "eum": "√´",
  "euml": "√´",
  "euro": "‚Ç¨",
  "excl": "!",
  "exist": "‚àÉ",
  "expectation": "‚Ñ∞",
  "exponentiale": "‚Öá",
  "fallingdotseq": "‚âí",
  "fcy": "—Ñ",
  "female": "‚ôÄ",
  "ffilig": "Ô¨É",
  "fflig": "Ô¨Ä",
  "ffllig": "Ô¨Ñ",
  "ffr": "ùî£",
  "filig": "Ô¨Å",
  "fjlig": "fj",
  "flat": "‚ô≠",
  "fllig": "Ô¨Ç",
  "fltns": "‚ñ±",
  "fnof": "∆í",
  "fopf": "ùïó",
  "forall": "‚àÄ",
  "fork": "‚ãî",
  "forkv": "‚´ô",
  "fpartint": "‚®ç",
  "frac1": "¬º",
  "frac12": "¬Ω",
  "frac13": "‚Öì",
  "frac14": "¬º",
  "frac15": "‚Öï",
  "frac16": "‚Öô",
  "frac18": "‚Öõ",
  "frac23": "‚Öî",
  "frac25": "‚Öñ",
  "frac3": "¬æ",
  "frac34": "¬æ",
  "frac35": "‚Öó",
  "frac38": "‚Öú",
  "frac45": "‚Öò",
  "frac56": "‚Öö",
  "frac58": "‚Öù",
  "frac78": "‚Öû",
  "frasl": "‚ÅÑ",
  "frown": "‚å¢",
  "fscr": "ùíª",
  "gE": "‚âß",
  "gEl": "‚™å",
  "gacute": "«µ",
  "gamma": "Œ≥",
  "gammad": "œù",
  "gap": "‚™Ü",
  "gbreve": "ƒü",
  "gcirc": "ƒù",
  "gcy": "–≥",
  "gdot": "ƒ°",
  "ge": "‚â•",
  "gel": "‚ãõ",
  "geq": "‚â•",
  "geqq": "‚âß",
  "geqslant": "‚©æ",
  "ges": "‚©æ",
  "gescc": "‚™©",
  "gesdot": "‚™Ä",
  "gesdoto": "‚™Ç",
  "gesdotol": "‚™Ñ",
  "gesl": "‚ãõÔ∏Ä",
  "gesles": "‚™î",
  "gfr": "ùî§",
  "gg": "‚â´",
  "ggg": "‚ãô",
  "gimel": "‚Ñ∑",
  "gjcy": "—ì",
  "gl": "‚â∑",
  "glE": "‚™í",
  "gla": "‚™•",
  "glj": "‚™§",
  "gnE": "‚â©",
  "gnap": "‚™ä",
  "gnapprox": "‚™ä",
  "gne": "‚™à",
  "gneq": "‚™à",
  "gneqq": "‚â©",
  "gnsim": "‚ãß",
  "gopf": "ùïò",
  "grave": "`",
  "gscr": "‚Ñä",
  "gsim": "‚â≥",
  "gsime": "‚™é",
  "gsiml": "‚™ê",
  "g": ">",
  "gt": ">",
  "gtcc": "‚™ß",
  "gtcir": "‚©∫",
  "gtdot": "‚ãó",
  "gtlPar": "‚¶ï",
  "gtquest": "‚©º",
  "gtrapprox": "‚™Ü",
  "gtrarr": "‚•∏",
  "gtrdot": "‚ãó",
  "gtreqless": "‚ãõ",
  "gtreqqless": "‚™å",
  "gtrless": "‚â∑",
  "gtrsim": "‚â≥",
  "gvertneqq": "‚â©Ô∏Ä",
  "gvnE": "‚â©Ô∏Ä",
  "hArr": "‚áî",
  "hairsp": "‚Ää",
  "half": "¬Ω",
  "hamilt": "‚Ñã",
  "hardcy": "—ä",
  "harr": "‚Üî",
  "harrcir": "‚•à",
  "harrw": "‚Ü≠",
  "hbar": "‚Ñè",
  "hcirc": "ƒ•",
  "hearts": "‚ô•",
  "heartsuit": "‚ô•",
  "hellip": "‚Ä¶",
  "hercon": "‚äπ",
  "hfr": "ùî•",
  "hksearow": "‚§•",
  "hkswarow": "‚§¶",
  "hoarr": "‚áø",
  "homtht": "‚àª",
  "hookleftarrow": "‚Ü©",
  "hookrightarrow": "‚Ü™",
  "hopf": "ùïô",
  "horbar": "‚Äï",
  "hscr": "ùíΩ",
  "hslash": "‚Ñè",
  "hstrok": "ƒß",
  "hybull": "‚ÅÉ",
  "hyphen": "‚Äê",
  "iacut": "√≠",
  "iacute": "√≠",
  "ic": "‚Å£",
  "icir": "√Æ",
  "icirc": "√Æ",
  "icy": "–∏",
  "iecy": "–µ",
  "iexc": "¬°",
  "iexcl": "¬°",
  "iff": "‚áî",
  "ifr": "ùî¶",
  "igrav": "√¨",
  "igrave": "√¨",
  "ii": "‚Öà",
  "iiiint": "‚®å",
  "iiint": "‚à≠",
  "iinfin": "‚ßú",
  "iiota": "‚Ñ©",
  "ijlig": "ƒ≥",
  "imacr": "ƒ´",
  "image": "‚Ñë",
  "imagline": "‚Ñê",
  "imagpart": "‚Ñë",
  "imath": "ƒ±",
  "imof": "‚ä∑",
  "imped": "∆µ",
  "in": "‚àà",
  "incare": "‚ÑÖ",
  "infin": "‚àû",
  "infintie": "‚ßù",
  "inodot": "ƒ±",
  "int": "‚à´",
  "intcal": "‚ä∫",
  "integers": "‚Ñ§",
  "intercal": "‚ä∫",
  "intlarhk": "‚®ó",
  "intprod": "‚®º",
  "iocy": "—ë",
  "iogon": "ƒØ",
  "iopf": "ùïö",
  "iota": "Œπ",
  "iprod": "‚®º",
  "iques": "¬ø",
  "iquest": "¬ø",
  "iscr": "ùíæ",
  "isin": "‚àà",
  "isinE": "‚ãπ",
  "isindot": "‚ãµ",
  "isins": "‚ã¥",
  "isinsv": "‚ã≥",
  "isinv": "‚àà",
  "it": "‚Å¢",
  "itilde": "ƒ©",
  "iukcy": "—ñ",
  "ium": "√Ø",
  "iuml": "√Ø",
  "jcirc": "ƒµ",
  "jcy": "–π",
  "jfr": "ùîß",
  "jmath": "»∑",
  "jopf": "ùïõ",
  "jscr": "ùíø",
  "jsercy": "—ò",
  "jukcy": "—î",
  "kappa": "Œ∫",
  "kappav": "œ∞",
  "kcedil": "ƒ∑",
  "kcy": "–∫",
  "kfr": "ùî®",
  "kgreen": "ƒ∏",
  "khcy": "—Ö",
  "kjcy": "—ú",
  "kopf": "ùïú",
  "kscr": "ùìÄ",
  "lAarr": "‚áö",
  "lArr": "‚áê",
  "lAtail": "‚§õ",
  "lBarr": "‚§é",
  "lE": "‚â¶",
  "lEg": "‚™ã",
  "lHar": "‚•¢",
  "lacute": "ƒ∫",
  "laemptyv": "‚¶¥",
  "lagran": "‚Ñí",
  "lambda": "Œª",
  "lang": "‚ü®",
  "langd": "‚¶ë",
  "langle": "‚ü®",
  "lap": "‚™Ö",
  "laqu": "¬´",
  "laquo": "¬´",
  "larr": "‚Üê",
  "larrb": "‚á§",
  "larrbfs": "‚§ü",
  "larrfs": "‚§ù",
  "larrhk": "‚Ü©",
  "larrlp": "‚Ü´",
  "larrpl": "‚§π",
  "larrsim": "‚•≥",
  "larrtl": "‚Ü¢",
  "lat": "‚™´",
  "latail": "‚§ô",
  "late": "‚™≠",
  "lates": "‚™≠Ô∏Ä",
  "lbarr": "‚§å",
  "lbbrk": "‚ù≤",
  "lbrace": "{",
  "lbrack": "[",
  "lbrke": "‚¶ã",
  "lbrksld": "‚¶è",
  "lbrkslu": "‚¶ç",
  "lcaron": "ƒæ",
  "lcedil": "ƒº",
  "lceil": "‚åà",
  "lcub": "{",
  "lcy": "–ª",
  "ldca": "‚§∂",
  "ldquo": "‚Äú",
  "ldquor": "‚Äû",
  "ldrdhar": "‚•ß",
  "ldrushar": "‚•ã",
  "ldsh": "‚Ü≤",
  "le": "‚â§",
  "leftarrow": "‚Üê",
  "leftarrowtail": "‚Ü¢",
  "leftharpoondown": "‚ÜΩ",
  "leftharpoonup": "‚Üº",
  "leftleftarrows": "‚áá",
  "leftrightarrow": "‚Üî",
  "leftrightarrows": "‚áÜ",
  "leftrightharpoons": "‚áã",
  "leftrightsquigarrow": "‚Ü≠",
  "leftthreetimes": "‚ãã",
  "leg": "‚ãö",
  "leq": "‚â§",
  "leqq": "‚â¶",
  "leqslant": "‚©Ω",
  "les": "‚©Ω",
  "lescc": "‚™®",
  "lesdot": "‚©ø",
  "lesdoto": "‚™Å",
  "lesdotor": "‚™É",
  "lesg": "‚ãöÔ∏Ä",
  "lesges": "‚™ì",
  "lessapprox": "‚™Ö",
  "lessdot": "‚ãñ",
  "lesseqgtr": "‚ãö",
  "lesseqqgtr": "‚™ã",
  "lessgtr": "‚â∂",
  "lesssim": "‚â≤",
  "lfisht": "‚•º",
  "lfloor": "‚åä",
  "lfr": "ùî©",
  "lg": "‚â∂",
  "lgE": "‚™ë",
  "lhard": "‚ÜΩ",
  "lharu": "‚Üº",
  "lharul": "‚•™",
  "lhblk": "‚ñÑ",
  "ljcy": "—ô",
  "ll": "‚â™",
  "llarr": "‚áá",
  "llcorner": "‚åû",
  "llhard": "‚•´",
  "lltri": "‚ó∫",
  "lmidot": "≈Ä",
  "lmoust": "‚é∞",
  "lmoustache": "‚é∞",
  "lnE": "‚â®",
  "lnap": "‚™â",
  "lnapprox": "‚™â",
  "lne": "‚™á",
  "lneq": "‚™á",
  "lneqq": "‚â®",
  "lnsim": "‚ã¶",
  "loang": "‚ü¨",
  "loarr": "‚áΩ",
  "lobrk": "‚ü¶",
  "longleftarrow": "‚üµ",
  "longleftrightarrow": "‚ü∑",
  "longmapsto": "‚üº",
  "longrightarrow": "‚ü∂",
  "looparrowleft": "‚Ü´",
  "looparrowright": "‚Ü¨",
  "lopar": "‚¶Ö",
  "lopf": "ùïù",
  "loplus": "‚®≠",
  "lotimes": "‚®¥",
  "lowast": "‚àó",
  "lowbar": "_",
  "loz": "‚óä",
  "lozenge": "‚óä",
  "lozf": "‚ß´",
  "lpar": "(",
  "lparlt": "‚¶ì",
  "lrarr": "‚áÜ",
  "lrcorner": "‚åü",
  "lrhar": "‚áã",
  "lrhard": "‚•≠",
  "lrm": "‚Äé",
  "lrtri": "‚äø",
  "lsaquo": "‚Äπ",
  "lscr": "ùìÅ",
  "lsh": "‚Ü∞",
  "lsim": "‚â≤",
  "lsime": "‚™ç",
  "lsimg": "‚™è",
  "lsqb": "[",
  "lsquo": "‚Äò",
  "lsquor": "‚Äö",
  "lstrok": "≈Ç",
  "l": "<",
  "lt": "<",
  "ltcc": "‚™¶",
  "ltcir": "‚©π",
  "ltdot": "‚ãñ",
  "lthree": "‚ãã",
  "ltimes": "‚ãâ",
  "ltlarr": "‚•∂",
  "ltquest": "‚©ª",
  "ltrPar": "‚¶ñ",
  "ltri": "‚óÉ",
  "ltrie": "‚ä¥",
  "ltrif": "‚óÇ",
  "lurdshar": "‚•ä",
  "luruhar": "‚•¶",
  "lvertneqq": "‚â®Ô∏Ä",
  "lvnE": "‚â®Ô∏Ä",
  "mDDot": "‚à∫",
  "mac": "¬Ø",
  "macr": "¬Ø",
  "male": "‚ôÇ",
  "malt": "‚ú†",
  "maltese": "‚ú†",
  "map": "‚Ü¶",
  "mapsto": "‚Ü¶",
  "mapstodown": "‚Üß",
  "mapstoleft": "‚Ü§",
  "mapstoup": "‚Ü•",
  "marker": "‚ñÆ",
  "mcomma": "‚®©",
  "mcy": "–º",
  "mdash": "‚Äî",
  "measuredangle": "‚à°",
  "mfr": "ùî™",
  "mho": "‚Ñß",
  "micr": "¬µ",
  "micro": "¬µ",
  "mid": "‚à£",
  "midast": "*",
  "midcir": "‚´∞",
  "middo": "¬∑",
  "middot": "¬∑",
  "minus": "‚àí",
  "minusb": "‚äü",
  "minusd": "‚à∏",
  "minusdu": "‚®™",
  "mlcp": "‚´õ",
  "mldr": "‚Ä¶",
  "mnplus": "‚àì",
  "models": "‚äß",
  "mopf": "ùïû",
  "mp": "‚àì",
  "mscr": "ùìÇ",
  "mstpos": "‚àæ",
  "mu": "Œº",
  "multimap": "‚ä∏",
  "mumap": "‚ä∏",
  "nGg": "‚ãôÃ∏",
  "nGt": "‚â´‚Éí",
  "nGtv": "‚â´Ã∏",
  "nLeftarrow": "‚áç",
  "nLeftrightarrow": "‚áé",
  "nLl": "‚ãòÃ∏",
  "nLt": "‚â™‚Éí",
  "nLtv": "‚â™Ã∏",
  "nRightarrow": "‚áè",
  "nVDash": "‚äØ",
  "nVdash": "‚äÆ",
  "nabla": "‚àá",
  "nacute": "≈Ñ",
  "nang": "‚à†‚Éí",
  "nap": "‚ââ",
  "napE": "‚©∞Ã∏",
  "napid": "‚âãÃ∏",
  "napos": "≈â",
  "napprox": "‚ââ",
  "natur": "‚ôÆ",
  "natural": "‚ôÆ",
  "naturals": "‚Ñï",
  "nbs": "¬†",
  "nbsp": "¬†",
  "nbump": "‚âéÃ∏",
  "nbumpe": "‚âèÃ∏",
  "ncap": "‚©É",
  "ncaron": "≈à",
  "ncedil": "≈Ü",
  "ncong": "‚âá",
  "ncongdot": "‚©≠Ã∏",
  "ncup": "‚©Ç",
  "ncy": "–Ω",
  "ndash": "‚Äì",
  "ne": "‚â†",
  "neArr": "‚áó",
  "nearhk": "‚§§",
  "nearr": "‚Üó",
  "nearrow": "‚Üó",
  "nedot": "‚âêÃ∏",
  "nequiv": "‚â¢",
  "nesear": "‚§®",
  "nesim": "‚âÇÃ∏",
  "nexist": "‚àÑ",
  "nexists": "‚àÑ",
  "nfr": "ùî´",
  "ngE": "‚âßÃ∏",
  "nge": "‚â±",
  "ngeq": "‚â±",
  "ngeqq": "‚âßÃ∏",
  "ngeqslant": "‚©æÃ∏",
  "nges": "‚©æÃ∏",
  "ngsim": "‚âµ",
  "ngt": "‚âØ",
  "ngtr": "‚âØ",
  "nhArr": "‚áé",
  "nharr": "‚ÜÆ",
  "nhpar": "‚´≤",
  "ni": "‚àã",
  "nis": "‚ãº",
  "nisd": "‚ã∫",
  "niv": "‚àã",
  "njcy": "—ö",
  "nlArr": "‚áç",
  "nlE": "‚â¶Ã∏",
  "nlarr": "‚Üö",
  "nldr": "‚Ä•",
  "nle": "‚â∞",
  "nleftarrow": "‚Üö",
  "nleftrightarrow": "‚ÜÆ",
  "nleq": "‚â∞",
  "nleqq": "‚â¶Ã∏",
  "nleqslant": "‚©ΩÃ∏",
  "nles": "‚©ΩÃ∏",
  "nless": "‚âÆ",
  "nlsim": "‚â¥",
  "nlt": "‚âÆ",
  "nltri": "‚ã™",
  "nltrie": "‚ã¨",
  "nmid": "‚à§",
  "nopf": "ùïü",
  "no": "¬¨",
  "not": "¬¨",
  "notin": "‚àâ",
  "notinE": "‚ãπÃ∏",
  "notindot": "‚ãµÃ∏",
  "notinva": "‚àâ",
  "notinvb": "‚ã∑",
  "notinvc": "‚ã∂",
  "notni": "‚àå",
  "notniva": "‚àå",
  "notnivb": "‚ãæ",
  "notnivc": "‚ãΩ",
  "npar": "‚à¶",
  "nparallel": "‚à¶",
  "nparsl": "‚´Ω‚É•",
  "npart": "‚àÇÃ∏",
  "npolint": "‚®î",
  "npr": "‚äÄ",
  "nprcue": "‚ã†",
  "npre": "‚™ØÃ∏",
  "nprec": "‚äÄ",
  "npreceq": "‚™ØÃ∏",
  "nrArr": "‚áè",
  "nrarr": "‚Üõ",
  "nrarrc": "‚§≥Ã∏",
  "nrarrw": "‚ÜùÃ∏",
  "nrightarrow": "‚Üõ",
  "nrtri": "‚ã´",
  "nrtrie": "‚ã≠",
  "nsc": "‚äÅ",
  "nsccue": "‚ã°",
  "nsce": "‚™∞Ã∏",
  "nscr": "ùìÉ",
  "nshortmid": "‚à§",
  "nshortparallel": "‚à¶",
  "nsim": "‚âÅ",
  "nsime": "‚âÑ",
  "nsimeq": "‚âÑ",
  "nsmid": "‚à§",
  "nspar": "‚à¶",
  "nsqsube": "‚ã¢",
  "nsqsupe": "‚ã£",
  "nsub": "‚äÑ",
  "nsubE": "‚´ÖÃ∏",
  "nsube": "‚äà",
  "nsubset": "‚äÇ‚Éí",
  "nsubseteq": "‚äà",
  "nsubseteqq": "‚´ÖÃ∏",
  "nsucc": "‚äÅ",
  "nsucceq": "‚™∞Ã∏",
  "nsup": "‚äÖ",
  "nsupE": "‚´ÜÃ∏",
  "nsupe": "‚äâ",
  "nsupset": "‚äÉ‚Éí",
  "nsupseteq": "‚äâ",
  "nsupseteqq": "‚´ÜÃ∏",
  "ntgl": "‚âπ",
  "ntild": "√±",
  "ntilde": "√±",
  "ntlg": "‚â∏",
  "ntriangleleft": "‚ã™",
  "ntrianglelefteq": "‚ã¨",
  "ntriangleright": "‚ã´",
  "ntrianglerighteq": "‚ã≠",
  "nu": "ŒΩ",
  "num": "#",
  "numero": "‚Ññ",
  "numsp": "‚Äá",
  "nvDash": "‚ä≠",
  "nvHarr": "‚§Ñ",
  "nvap": "‚âç‚Éí",
  "nvdash": "‚ä¨",
  "nvge": "‚â•‚Éí",
  "nvgt": ">‚Éí",
  "nvinfin": "‚ßû",
  "nvlArr": "‚§Ç",
  "nvle": "‚â§‚Éí",
  "nvlt": "<‚Éí",
  "nvltrie": "‚ä¥‚Éí",
  "nvrArr": "‚§É",
  "nvrtrie": "‚äµ‚Éí",
  "nvsim": "‚àº‚Éí",
  "nwArr": "‚áñ",
  "nwarhk": "‚§£",
  "nwarr": "‚Üñ",
  "nwarrow": "‚Üñ",
  "nwnear": "‚§ß",
  "oS": "‚ìà",
  "oacut": "√≥",
  "oacute": "√≥",
  "oast": "‚äõ",
  "ocir": "√¥",
  "ocirc": "√¥",
  "ocy": "–æ",
  "odash": "‚äù",
  "odblac": "≈ë",
  "odiv": "‚®∏",
  "odot": "‚äô",
  "odsold": "‚¶º",
  "oelig": "≈ì",
  "ofcir": "‚¶ø",
  "ofr": "ùî¨",
  "ogon": "Àõ",
  "ograv": "√≤",
  "ograve": "√≤",
  "ogt": "‚ßÅ",
  "ohbar": "‚¶µ",
  "ohm": "Œ©",
  "oint": "‚àÆ",
  "olarr": "‚Ü∫",
  "olcir": "‚¶æ",
  "olcross": "‚¶ª",
  "oline": "‚Äæ",
  "olt": "‚ßÄ",
  "omacr": "≈ç",
  "omega": "œâ",
  "omicron": "Œø",
  "omid": "‚¶∂",
  "ominus": "‚äñ",
  "oopf": "ùï†",
  "opar": "‚¶∑",
  "operp": "‚¶π",
  "oplus": "‚äï",
  "or": "‚à®",
  "orarr": "‚Üª",
  "ord": "¬∫",
  "order": "‚Ñ¥",
  "orderof": "‚Ñ¥",
  "ordf": "¬™",
  "ordm": "¬∫",
  "origof": "‚ä∂",
  "oror": "‚©ñ",
  "orslope": "‚©ó",
  "orv": "‚©õ",
  "oscr": "‚Ñ¥",
  "oslas": "√∏",
  "oslash": "√∏",
  "osol": "‚äò",
  "otild": "√µ",
  "otilde": "√µ",
  "otimes": "‚äó",
  "otimesas": "‚®∂",
  "oum": "√∂",
  "ouml": "√∂",
  "ovbar": "‚åΩ",
  "par": "¬∂",
  "para": "¬∂",
  "parallel": "‚à•",
  "parsim": "‚´≥",
  "parsl": "‚´Ω",
  "part": "‚àÇ",
  "pcy": "–ø",
  "percnt": "%",
  "period": ".",
  "permil": "‚Ä∞",
  "perp": "‚ä•",
  "pertenk": "‚Ä±",
  "pfr": "ùî≠",
  "phi": "œÜ",
  "phiv": "œï",
  "phmmat": "‚Ñ≥",
  "phone": "‚òé",
  "pi": "œÄ",
  "pitchfork": "‚ãî",
  "piv": "œñ",
  "planck": "‚Ñè",
  "planckh": "‚Ñé",
  "plankv": "‚Ñè",
  "plus": "+",
  "plusacir": "‚®£",
  "plusb": "‚äû",
  "pluscir": "‚®¢",
  "plusdo": "‚àî",
  "plusdu": "‚®•",
  "pluse": "‚©≤",
  "plusm": "¬±",
  "plusmn": "¬±",
  "plussim": "‚®¶",
  "plustwo": "‚®ß",
  "pm": "¬±",
  "pointint": "‚®ï",
  "popf": "ùï°",
  "poun": "¬£",
  "pound": "¬£",
  "pr": "‚â∫",
  "prE": "‚™≥",
  "prap": "‚™∑",
  "prcue": "‚âº",
  "pre": "‚™Ø",
  "prec": "‚â∫",
  "precapprox": "‚™∑",
  "preccurlyeq": "‚âº",
  "preceq": "‚™Ø",
  "precnapprox": "‚™π",
  "precneqq": "‚™µ",
  "precnsim": "‚ã®",
  "precsim": "‚âæ",
  "prime": "‚Ä≤",
  "primes": "‚Ñô",
  "prnE": "‚™µ",
  "prnap": "‚™π",
  "prnsim": "‚ã®",
  "prod": "‚àè",
  "profalar": "‚åÆ",
  "profline": "‚åí",
  "profsurf": "‚åì",
  "prop": "‚àù",
  "propto": "‚àù",
  "prsim": "‚âæ",
  "prurel": "‚ä∞",
  "pscr": "ùìÖ",
  "psi": "œà",
  "puncsp": "‚Äà",
  "qfr": "ùîÆ",
  "qint": "‚®å",
  "qopf": "ùï¢",
  "qprime": "‚Åó",
  "qscr": "ùìÜ",
  "quaternions": "‚Ñç",
  "quatint": "‚®ñ",
  "quest": "?",
  "questeq": "‚âü",
  "quo": "\"",
  "quot": "\"",
  "rAarr": "‚áõ",
  "rArr": "‚áí",
  "rAtail": "‚§ú",
  "rBarr": "‚§è",
  "rHar": "‚•§",
  "race": "‚àΩÃ±",
  "racute": "≈ï",
  "radic": "‚àö",
  "raemptyv": "‚¶≥",
  "rang": "‚ü©",
  "rangd": "‚¶í",
  "range": "‚¶•",
  "rangle": "‚ü©",
  "raqu": "¬ª",
  "raquo": "¬ª",
  "rarr": "‚Üí",
  "rarrap": "‚•µ",
  "rarrb": "‚á•",
  "rarrbfs": "‚§†",
  "rarrc": "‚§≥",
  "rarrfs": "‚§û",
  "rarrhk": "‚Ü™",
  "rarrlp": "‚Ü¨",
  "rarrpl": "‚•Ö",
  "rarrsim": "‚•¥",
  "rarrtl": "‚Ü£",
  "rarrw": "‚Üù",
  "ratail": "‚§ö",
  "ratio": "‚à∂",
  "rationals": "‚Ñö",
  "rbarr": "‚§ç",
  "rbbrk": "‚ù≥",
  "rbrace": "}",
  "rbrack": "]",
  "rbrke": "‚¶å",
  "rbrksld": "‚¶é",
  "rbrkslu": "‚¶ê",
  "rcaron": "≈ô",
  "rcedil": "≈ó",
  "rceil": "‚åâ",
  "rcub": "}",
  "rcy": "—Ä",
  "rdca": "‚§∑",
  "rdldhar": "‚•©",
  "rdquo": "‚Äù",
  "rdquor": "‚Äù",
  "rdsh": "‚Ü≥",
  "real": "‚Ñú",
  "realine": "‚Ñõ",
  "realpart": "‚Ñú",
  "reals": "‚Ñù",
  "rect": "‚ñ≠",
  "re": "¬Æ",
  "reg": "¬Æ",
  "rfisht": "‚•Ω",
  "rfloor": "‚åã",
  "rfr": "ùîØ",
  "rhard": "‚áÅ",
  "rharu": "‚áÄ",
  "rharul": "‚•¨",
  "rho": "œÅ",
  "rhov": "œ±",
  "rightarrow": "‚Üí",
  "rightarrowtail": "‚Ü£",
  "rightharpoondown": "‚áÅ",
  "rightharpoonup": "‚áÄ",
  "rightleftarrows": "‚áÑ",
  "rightleftharpoons": "‚áå",
  "rightrightarrows": "‚áâ",
  "rightsquigarrow": "‚Üù",
  "rightthreetimes": "‚ãå",
  "ring": "Àö",
  "risingdotseq": "‚âì",
  "rlarr": "‚áÑ",
  "rlhar": "‚áå",
  "rlm": "‚Äè",
  "rmoust": "‚é±",
  "rmoustache": "‚é±",
  "rnmid": "‚´Æ",
  "roang": "‚ü≠",
  "roarr": "‚áæ",
  "robrk": "‚üß",
  "ropar": "‚¶Ü",
  "ropf": "ùï£",
  "roplus": "‚®Æ",
  "rotimes": "‚®µ",
  "rpar": ")",
  "rpargt": "‚¶î",
  "rppolint": "‚®í",
  "rrarr": "‚áâ",
  "rsaquo": "‚Ä∫",
  "rscr": "ùìá",
  "rsh": "‚Ü±",
  "rsqb": "]",
  "rsquo": "‚Äô",
  "rsquor": "‚Äô",
  "rthree": "‚ãå",
  "rtimes": "‚ãä",
  "rtri": "‚ñπ",
  "rtrie": "‚äµ",
  "rtrif": "‚ñ∏",
  "rtriltri": "‚ßé",
  "ruluhar": "‚•®",
  "rx": "‚Ñû",
  "sacute": "≈õ",
  "sbquo": "‚Äö",
  "sc": "‚âª",
  "scE": "‚™¥",
  "scap": "‚™∏",
  "scaron": "≈°",
  "sccue": "‚âΩ",
  "sce": "‚™∞",
  "scedil": "≈ü",
  "scirc": "≈ù",
  "scnE": "‚™∂",
  "scnap": "‚™∫",
  "scnsim": "‚ã©",
  "scpolint": "‚®ì",
  "scsim": "‚âø",
  "scy": "—Å",
  "sdot": "‚ãÖ",
  "sdotb": "‚ä°",
  "sdote": "‚©¶",
  "seArr": "‚áò",
  "searhk": "‚§•",
  "searr": "‚Üò",
  "searrow": "‚Üò",
  "sec": "¬ß",
  "sect": "¬ß",
  "semi": ";",
  "seswar": "‚§©",
  "setminus": "‚àñ",
  "setmn": "‚àñ",
  "sext": "‚ú∂",
  "sfr": "ùî∞",
  "sfrown": "‚å¢",
  "sharp": "‚ôØ",
  "shchcy": "—â",
  "shcy": "—à",
  "shortmid": "‚à£",
  "shortparallel": "‚à•",
  "sh": "¬≠",
  "shy": "¬≠",
  "sigma": "œÉ",
  "sigmaf": "œÇ",
  "sigmav": "œÇ",
  "sim": "‚àº",
  "simdot": "‚©™",
  "sime": "‚âÉ",
  "simeq": "‚âÉ",
  "simg": "‚™û",
  "simgE": "‚™†",
  "siml": "‚™ù",
  "simlE": "‚™ü",
  "simne": "‚âÜ",
  "simplus": "‚®§",
  "simrarr": "‚•≤",
  "slarr": "‚Üê",
  "smallsetminus": "‚àñ",
  "smashp": "‚®≥",
  "smeparsl": "‚ß§",
  "smid": "‚à£",
  "smile": "‚å£",
  "smt": "‚™™",
  "smte": "‚™¨",
  "smtes": "‚™¨Ô∏Ä",
  "softcy": "—å",
  "sol": "/",
  "solb": "‚ßÑ",
  "solbar": "‚åø",
  "sopf": "ùï§",
  "spades": "‚ô†",
  "spadesuit": "‚ô†",
  "spar": "‚à•",
  "sqcap": "‚äì",
  "sqcaps": "‚äìÔ∏Ä",
  "sqcup": "‚äî",
  "sqcups": "‚äîÔ∏Ä",
  "sqsub": "‚äè",
  "sqsube": "‚äë",
  "sqsubset": "‚äè",
  "sqsubseteq": "‚äë",
  "sqsup": "‚äê",
  "sqsupe": "‚äí",
  "sqsupset": "‚äê",
  "sqsupseteq": "‚äí",
  "squ": "‚ñ°",
  "square": "‚ñ°",
  "squarf": "‚ñ™",
  "squf": "‚ñ™",
  "srarr": "‚Üí",
  "sscr": "ùìà",
  "ssetmn": "‚àñ",
  "ssmile": "‚å£",
  "sstarf": "‚ãÜ",
  "star": "‚òÜ",
  "starf": "‚òÖ",
  "straightepsilon": "œµ",
  "straightphi": "œï",
  "strns": "¬Ø",
  "sub": "‚äÇ",
  "subE": "‚´Ö",
  "subdot": "‚™Ω",
  "sube": "‚äÜ",
  "subedot": "‚´É",
  "submult": "‚´Å",
  "subnE": "‚´ã",
  "subne": "‚ää",
  "subplus": "‚™ø",
  "subrarr": "‚•π",
  "subset": "‚äÇ",
  "subseteq": "‚äÜ",
  "subseteqq": "‚´Ö",
  "subsetneq": "‚ää",
  "subsetneqq": "‚´ã",
  "subsim": "‚´á",
  "subsub": "‚´ï",
  "subsup": "‚´ì",
  "succ": "‚âª",
  "succapprox": "‚™∏",
  "succcurlyeq": "‚âΩ",
  "succeq": "‚™∞",
  "succnapprox": "‚™∫",
  "succneqq": "‚™∂",
  "succnsim": "‚ã©",
  "succsim": "‚âø",
  "sum": "‚àë",
  "sung": "‚ô™",
  "sup": "‚äÉ",
  "sup1": "¬π",
  "sup2": "¬≤",
  "sup3": "¬≥",
  "supE": "‚´Ü",
  "supdot": "‚™æ",
  "supdsub": "‚´ò",
  "supe": "‚äá",
  "supedot": "‚´Ñ",
  "suphsol": "‚üâ",
  "suphsub": "‚´ó",
  "suplarr": "‚•ª",
  "supmult": "‚´Ç",
  "supnE": "‚´å",
  "supne": "‚äã",
  "supplus": "‚´Ä",
  "supset": "‚äÉ",
  "supseteq": "‚äá",
  "supseteqq": "‚´Ü",
  "supsetneq": "‚äã",
  "supsetneqq": "‚´å",
  "supsim": "‚´à",
  "supsub": "‚´î",
  "supsup": "‚´ñ",
  "swArr": "‚áô",
  "swarhk": "‚§¶",
  "swarr": "‚Üô",
  "swarrow": "‚Üô",
  "swnwar": "‚§™",
  "szli": "√ü",
  "szlig": "√ü",
  "target": "‚åñ",
  "tau": "œÑ",
  "tbrk": "‚é¥",
  "tcaron": "≈•",
  "tcedil": "≈£",
  "tcy": "—Ç",
  "tdot": "‚Éõ",
  "telrec": "‚åï",
  "tfr": "ùî±",
  "there4": "‚à¥",
  "therefore": "‚à¥",
  "theta": "Œ∏",
  "thetasym": "œë",
  "thetav": "œë",
  "thickapprox": "‚âà",
  "thicksim": "‚àº",
  "thinsp": "‚Äâ",
  "thkap": "‚âà",
  "thksim": "‚àº",
  "thor": "√æ",
  "thorn": "√æ",
  "tilde": "Àú",
  "time": "√ó",
  "times": "√ó",
  "timesb": "‚ä†",
  "timesbar": "‚®±",
  "timesd": "‚®∞",
  "tint": "‚à≠",
  "toea": "‚§®",
  "top": "‚ä§",
  "topbot": "‚å∂",
  "topcir": "‚´±",
  "topf": "ùï•",
  "topfork": "‚´ö",
  "tosa": "‚§©",
  "tprime": "‚Ä¥",
  "trade": "‚Ñ¢",
  "triangle": "‚ñµ",
  "triangledown": "‚ñø",
  "triangleleft": "‚óÉ",
  "trianglelefteq": "‚ä¥",
  "triangleq": "‚âú",
  "triangleright": "‚ñπ",
  "trianglerighteq": "‚äµ",
  "tridot": "‚ó¨",
  "trie": "‚âú",
  "triminus": "‚®∫",
  "triplus": "‚®π",
  "trisb": "‚ßç",
  "tritime": "‚®ª",
  "trpezium": "‚è¢",
  "tscr": "ùìâ",
  "tscy": "—Ü",
  "tshcy": "—õ",
  "tstrok": "≈ß",
  "twixt": "‚â¨",
  "twoheadleftarrow": "‚Üû",
  "twoheadrightarrow": "‚Ü†",
  "uArr": "‚áë",
  "uHar": "‚•£",
  "uacut": "√∫",
  "uacute": "√∫",
  "uarr": "‚Üë",
  "ubrcy": "—û",
  "ubreve": "≈≠",
  "ucir": "√ª",
  "ucirc": "√ª",
  "ucy": "—É",
  "udarr": "‚áÖ",
  "udblac": "≈±",
  "udhar": "‚•Æ",
  "ufisht": "‚•æ",
  "ufr": "ùî≤",
  "ugrav": "√π",
  "ugrave": "√π",
  "uharl": "‚Üø",
  "uharr": "‚Üæ",
  "uhblk": "‚ñÄ",
  "ulcorn": "‚åú",
  "ulcorner": "‚åú",
  "ulcrop": "‚åè",
  "ultri": "‚ó∏",
  "umacr": "≈´",
  "um": "¬®",
  "uml": "¬®",
  "uogon": "≈≥",
  "uopf": "ùï¶",
  "uparrow": "‚Üë",
  "updownarrow": "‚Üï",
  "upharpoonleft": "‚Üø",
  "upharpoonright": "‚Üæ",
  "uplus": "‚äé",
  "upsi": "œÖ",
  "upsih": "œí",
  "upsilon": "œÖ",
  "upuparrows": "‚áà",
  "urcorn": "‚åù",
  "urcorner": "‚åù",
  "urcrop": "‚åé",
  "uring": "≈Ø",
  "urtri": "‚óπ",
  "uscr": "ùìä",
  "utdot": "‚ã∞",
  "utilde": "≈©",
  "utri": "‚ñµ",
  "utrif": "‚ñ¥",
  "uuarr": "‚áà",
  "uum": "√º",
  "uuml": "√º",
  "uwangle": "‚¶ß",
  "vArr": "‚áï",
  "vBar": "‚´®",
  "vBarv": "‚´©",
  "vDash": "‚ä®",
  "vangrt": "‚¶ú",
  "varepsilon": "œµ",
  "varkappa": "œ∞",
  "varnothing": "‚àÖ",
  "varphi": "œï",
  "varpi": "œñ",
  "varpropto": "‚àù",
  "varr": "‚Üï",
  "varrho": "œ±",
  "varsigma": "œÇ",
  "varsubsetneq": "‚ääÔ∏Ä",
  "varsubsetneqq": "‚´ãÔ∏Ä",
  "varsupsetneq": "‚äãÔ∏Ä",
  "varsupsetneqq": "‚´åÔ∏Ä",
  "vartheta": "œë",
  "vartriangleleft": "‚ä≤",
  "vartriangleright": "‚ä≥",
  "vcy": "–≤",
  "vdash": "‚ä¢",
  "vee": "‚à®",
  "veebar": "‚äª",
  "veeeq": "‚âö",
  "vellip": "‚ãÆ",
  "verbar": "|",
  "vert": "|",
  "vfr": "ùî≥",
  "vltri": "‚ä≤",
  "vnsub": "‚äÇ‚Éí",
  "vnsup": "‚äÉ‚Éí",
  "vopf": "ùïß",
  "vprop": "‚àù",
  "vrtri": "‚ä≥",
  "vscr": "ùìã",
  "vsubnE": "‚´ãÔ∏Ä",
  "vsubne": "‚ääÔ∏Ä",
  "vsupnE": "‚´åÔ∏Ä",
  "vsupne": "‚äãÔ∏Ä",
  "vzigzag": "‚¶ö",
  "wcirc": "≈µ",
  "wedbar": "‚©ü",
  "wedge": "‚àß",
  "wedgeq": "‚âô",
  "weierp": "‚Ñò",
  "wfr": "ùî¥",
  "wopf": "ùï®",
  "wp": "‚Ñò",
  "wr": "‚âÄ",
  "wreath": "‚âÄ",
  "wscr": "ùìå",
  "xcap": "‚ãÇ",
  "xcirc": "‚óØ",
  "xcup": "‚ãÉ",
  "xdtri": "‚ñΩ",
  "xfr": "ùîµ",
  "xhArr": "‚ü∫",
  "xharr": "‚ü∑",
  "xi": "Œæ",
  "xlArr": "‚ü∏",
  "xlarr": "‚üµ",
  "xmap": "‚üº",
  "xnis": "‚ãª",
  "xodot": "‚®Ä",
  "xopf": "ùï©",
  "xoplus": "‚®Å",
  "xotime": "‚®Ç",
  "xrArr": "‚üπ",
  "xrarr": "‚ü∂",
  "xscr": "ùìç",
  "xsqcup": "‚®Ü",
  "xuplus": "‚®Ñ",
  "xutri": "‚ñ≥",
  "xvee": "‚ãÅ",
  "xwedge": "‚ãÄ",
  "yacut": "√Ω",
  "yacute": "√Ω",
  "yacy": "—è",
  "ycirc": "≈∑",
  "ycy": "—ã",
  "ye": "¬•",
  "yen": "¬•",
  "yfr": "ùî∂",
  "yicy": "—ó",
  "yopf": "ùï™",
  "yscr": "ùìé",
  "yucy": "—é",
  "yum": "√ø",
  "yuml": "√ø",
  "zacute": "≈∫",
  "zcaron": "≈æ",
  "zcy": "–∑",
  "zdot": "≈º",
  "zeetrf": "‚Ñ®",
  "zeta": "Œ∂",
  "zfr": "ùî∑",
  "zhcy": "–∂",
  "zigrarr": "‚áù",
  "zopf": "ùï´",
  "zscr": "ùìè",
  "zwj": "‚Äç",
  "zwnj": "‚Äå"
}

},{}],8:[function(require,module,exports){
module.exports={
  "0": "ÔøΩ",
  "128": "‚Ç¨",
  "130": "‚Äö",
  "131": "∆í",
  "132": "‚Äû",
  "133": "‚Ä¶",
  "134": "‚Ä†",
  "135": "‚Ä°",
  "136": "ÀÜ",
  "137": "‚Ä∞",
  "138": "≈†",
  "139": "‚Äπ",
  "140": "≈í",
  "142": "≈Ω",
  "145": "‚Äò",
  "146": "‚Äô",
  "147": "‚Äú",
  "148": "‚Äù",
  "149": "‚Ä¢",
  "150": "‚Äì",
  "151": "‚Äî",
  "152": "Àú",
  "153": "‚Ñ¢",
  "154": "≈°",
  "155": "‚Ä∫",
  "156": "≈ì",
  "158": "≈æ",
  "159": "≈∏"
}

},{}],9:[function(require,module,exports){
'use strict';

module.exports = collapse;

/* collapse(' \t\nbar \nbaz\t'); // ' bar baz ' */
function collapse(value) {
  return String(value).replace(/\s+/g, ' ');
}

},{}],10:[function(require,module,exports){
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						target[name] = copy;
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],11:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],12:[function(require,module,exports){
'use strict';

module.exports = alphabetical;

/* Check if the given character code, or the character
 * code at the first character, is alphabetical. */
function alphabetical(character) {
  var code = typeof character === 'string' ?
    character.charCodeAt(0) : character;

  return (code >= 97 && code <= 122) || /* a-z */
    (code >= 65 && code <= 90); /* A-Z */
}

},{}],13:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return !/[^0-9a-z\xDF-\xFF]/.test(str.toLowerCase());
};

},{}],14:[function(require,module,exports){
'use strict';

var alphabetical = require('is-alphabetical');
var decimal = require('is-decimal');

module.exports = alphanumerical;

/* Check if the given character code, or the character
 * code at the first character, is alphanumerical. */
function alphanumerical(character) {
  return alphabetical(character) || decimal(character);
}

},{"is-alphabetical":12,"is-decimal":16}],15:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],16:[function(require,module,exports){
'use strict';

module.exports = decimal;

/* Check if the given character code, or the character
 * code at the first character, is decimal. */
function decimal(character) {
  var code = typeof character === 'string' ?
    character.charCodeAt(0) : character;

  return code >= 48 && code <= 57; /* 0-9 */
}

},{}],17:[function(require,module,exports){
'use strict';

module.exports = hexadecimal;

/* Check if the given character code, or the character
 * code at the first character, is hexadecimal. */
function hexadecimal(character) {
  var code = typeof character === 'string' ?
    character.charCodeAt(0) : character;

  return (code >= 97 /* a */ && code <= 102 /* z */) ||
    (code >= 65 /* A */ && code <= 70 /* Z */) ||
    (code >= 48 /* A */ && code <= 57 /* Z */);
}

},{}],18:[function(require,module,exports){
'use strict';
var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

},{}],19:[function(require,module,exports){
'use strict';

module.exports = whitespace;

var fromCode = String.fromCharCode;
var re = /\s/;

/* Check if the given character code, or the character
 * code at the first character, is a whitespace character. */
function whitespace(character) {
  return re.test(
    typeof character === 'number' ? fromCode(character) : character.charAt(0)
  );
}

},{}],20:[function(require,module,exports){
'use strict';

module.exports = wordCharacter;

var fromCode = String.fromCharCode;
var re = /\w/;

/* Check if the given character code, or the character
 * code at the first character, is a word character. */
function wordCharacter(character) {
  return re.test(
    typeof character === 'number' ? fromCode(character) : character.charAt(0)
  );
}

},{}],21:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = longestStreak;

/* Get the count of the longest repeating streak of
 * `character` in `value`. */
function longestStreak(value, character) {
  var count = 0;
  var maximum = 0;
  var expected;
  var index;

  if (typeof character !== 'string' || character.length !== 1) {
    throw new Error('Expected character');
  }

  value = String(value);
  expected = index = value.indexOf(character);

  while (index !== -1) {
    count++;

    if (index === expected) {
      if (count > maximum) {
        maximum = count;
      }
    } else {
      count = 1;
    }

    expected = index + 1;
    index = value.indexOf(character, expected);
  }

  return maximum;
}

},{}],22:[function(require,module,exports){
'use strict';

module.exports = escapes;

var defaults = [
  '\\',
  '`',
  '*',
  '{',
  '}',
  '[',
  ']',
  '(',
  ')',
  '#',
  '+',
  '-',
  '.',
  '!',
  '_',
  '>'
];

var gfm = defaults.concat(['~', '|']);

var commonmark = gfm.concat([
  '\n',
  '"',
  '$',
  '%',
  '&',
  '\'',
  ',',
  '/',
  ':',
  ';',
  '<',
  '=',
  '?',
  '@',
  '^'
]);

escapes.default = defaults;
escapes.gfm = gfm;
escapes.commonmark = commonmark;

/* Get markdown escapes. */
function escapes(options) {
  var settings = options || {};

  if (settings.commonmark) {
    return commonmark;
  }

  return settings.gfm ? gfm : defaults;
}

},{}],23:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = markdownTable;

/* Expressions. */
var EXPRESSION_DOT = /\./;
var EXPRESSION_LAST_DOT = /\.[^.]*$/;

/* Allowed alignment values. */
var LEFT = 'l';
var RIGHT = 'r';
var CENTER = 'c';
var DOT = '.';
var NULL = '';

var ALLIGNMENT = [LEFT, RIGHT, CENTER, DOT, NULL];
var MIN_CELL_SIZE = 3;

/* Characters. */
var COLON = ':';
var DASH = '-';
var PIPE = '|';
var SPACE = ' ';
var NEW_LINE = '\n';

/* Create a table from a matrix of strings. */
function markdownTable(table, options) {
  var settings = options || {};
  var delimiter = settings.delimiter;
  var start = settings.start;
  var end = settings.end;
  var alignment = settings.align;
  var calculateStringLength = settings.stringLength || lengthNoop;
  var cellCount = 0;
  var rowIndex = -1;
  var rowLength = table.length;
  var sizes = [];
  var align;
  var rule;
  var rows;
  var row;
  var cells;
  var index;
  var position;
  var size;
  var value;
  var spacing;
  var before;
  var after;

  alignment = alignment ? alignment.concat() : [];

  if (delimiter === null || delimiter === undefined) {
    delimiter = SPACE + PIPE + SPACE;
  }

  if (start === null || start === undefined) {
    start = PIPE + SPACE;
  }

  if (end === null || end === undefined) {
    end = SPACE + PIPE;
  }

  while (++rowIndex < rowLength) {
    row = table[rowIndex];

    index = -1;

    if (row.length > cellCount) {
      cellCount = row.length;
    }

    while (++index < cellCount) {
      position = row[index] ? dotindex(row[index]) : null;

      if (!sizes[index]) {
        sizes[index] = MIN_CELL_SIZE;
      }

      if (position > sizes[index]) {
        sizes[index] = position;
      }
    }
  }

  if (typeof alignment === 'string') {
    alignment = pad(cellCount, alignment).split('');
  }

  /* Make sure only valid alignments are used. */
  index = -1;

  while (++index < cellCount) {
    align = alignment[index];

    if (typeof align === 'string') {
      align = align.charAt(0).toLowerCase();
    }

    if (ALLIGNMENT.indexOf(align) === -1) {
      align = NULL;
    }

    alignment[index] = align;
  }

  rowIndex = -1;
  rows = [];

  while (++rowIndex < rowLength) {
    row = table[rowIndex];

    index = -1;
    cells = [];

    while (++index < cellCount) {
      value = row[index];

      value = stringify(value);

      if (alignment[index] === DOT) {
        position = dotindex(value);

        size = sizes[index] +
          (EXPRESSION_DOT.test(value) ? 0 : 1) -
          (calculateStringLength(value) - position);

        cells[index] = value + pad(size - 1);
      } else {
        cells[index] = value;
      }
    }

    rows[rowIndex] = cells;
  }

  sizes = [];
  rowIndex = -1;

  while (++rowIndex < rowLength) {
    cells = rows[rowIndex];

    index = -1;

    while (++index < cellCount) {
      value = cells[index];

      if (!sizes[index]) {
        sizes[index] = MIN_CELL_SIZE;
      }

      size = calculateStringLength(value);

      if (size > sizes[index]) {
        sizes[index] = size;
      }
    }
  }

  rowIndex = -1;

  while (++rowIndex < rowLength) {
    cells = rows[rowIndex];

    index = -1;

    if (settings.pad !== false) {
      while (++index < cellCount) {
        value = cells[index];

        position = sizes[index] - (calculateStringLength(value) || 0);
        spacing = pad(position);

        if (alignment[index] === RIGHT || alignment[index] === DOT) {
          value = spacing + value;
        } else if (alignment[index] === CENTER) {
          position /= 2;

          if (position % 1 === 0) {
            before = position;
            after = position;
          } else {
            before = position + 0.5;
            after = position - 0.5;
          }

          value = pad(before) + value + pad(after);
        } else {
          value += spacing;
        }

        cells[index] = value;
      }
    }

    rows[rowIndex] = cells.join(delimiter);
  }

  if (settings.rule !== false) {
    index = -1;
    rule = [];

    while (++index < cellCount) {
      /* When `pad` is false, make the rule the same size as the first row. */
      if (settings.pad === false) {
        value = table[0][index];
        spacing = calculateStringLength(stringify(value));
        spacing = spacing > MIN_CELL_SIZE ? spacing : MIN_CELL_SIZE;
      } else {
        spacing = sizes[index];
      }

      align = alignment[index];

      /* When `align` is left, don't add colons. */
      value = align === RIGHT || align === NULL ? DASH : COLON;
      value += pad(spacing - 2, DASH);
      value += align !== LEFT && align !== NULL ? COLON : DASH;

      rule[index] = value;
    }

    rows.splice(1, 0, rule.join(delimiter));
  }

  return start + rows.join(end + NEW_LINE + start) + end;
}

function stringify(value) {
  return (value === null || value === undefined) ? '' : String(value);
}

/* Get the length of `value`. */
function lengthNoop(value) {
  return String(value).length;
}

/* Get a string consisting of `length` `character`s. */
function pad(length, character) {
  return Array(length + 1).join(character || SPACE);
}

/* Get the position of the last dot in `value`. */
function dotindex(value) {
  var match = EXPRESSION_LAST_DOT.exec(value);

  return match ? match.index + 1 : value.length;
}

},{}],24:[function(require,module,exports){
'use strict';

/* Dependencies. */
var visit = require('unist-util-visit');
var modify = require('unist-util-modify-children');

/* Expose. */
module.exports = compact;

/* Make an MDAST tree compact by merging adjacent text
 * nodes. */
function compact(tree, commonmark) {
  var modifier = modify(iterator);

  visit(tree, visitor);

  return tree;

  function visitor(node) {
    if (node.children) {
      modifier(node);
    }
  }

  function iterator(child, index, parent) {
    var siblings = parent.children;
    var prev = index && siblings[index - 1];

    if (
      prev &&
      child.type === prev.type &&
      mergeable(prev, commonmark) &&
      mergeable(child, commonmark)
    ) {
      if (child.value) {
        prev.value += child.value;
      }

      if (child.children) {
        prev.children = prev.children.concat(child.children);
      }

      siblings.splice(index, 1);

      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }

      return index;
    }
  }
}

function mergeable(node, commonmark) {
  var start;
  var end;

  if (node.type === 'text') {
    if (!node.position) {
      return true;
    }

    start = node.position.start;
    end = node.position.end;

    /* Only merge nodes which occupy the same size as their `value`. */
    return start.line !== end.line ||
      end.column - start.column === node.value.length;
  }

  return commonmark && node.type === 'blockquote';
}

},{"unist-util-modify-children":132,"unist-util-visit":135}],25:[function(require,module,exports){
'use strict';

/* Dependencies. */
var characterEntities = require('character-entities');
var legacy = require('character-entities-legacy');
var invalid = require('character-reference-invalid');
var decimal = require('is-decimal');
var hexadecimal = require('is-hexadecimal');
var alphanumerical = require('is-alphanumerical');

/* Expose. */
module.exports = wrapper;

/* Methods. */
var own = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop = Function.prototype;

/* Characters. */
var REPLACEMENT = '\uFFFD';
var FORM_FEED = '\f';
var AMPERSAND = '&';
var OCTOTHORP = '#';
var SEMICOLON = ';';
var NEWLINE = '\n';
var X_LOWER = 'x';
var X_UPPER = 'X';
var SPACE = ' ';
var LESS_THAN = '<';
var EQUAL = '=';
var EMPTY = '';
var TAB = '\t';

/* Default settings. */
var defaults = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};

/* Reference types. */
var NAMED = 'named';
var HEXADECIMAL = 'hexadecimal';
var DECIMAL = 'decimal';

/* Map of bases. */
var BASE = {};

BASE[HEXADECIMAL] = 16;
BASE[DECIMAL] = 10;

/* Map of types to tests. Each type of character reference
 * accepts different characters. This test is used to
 * detect whether a reference has ended (as the semicolon
 * is not strictly needed). */
var TESTS = {};

TESTS[NAMED] = alphanumerical;
TESTS[DECIMAL] = decimal;
TESTS[HEXADECIMAL] = hexadecimal;

/* Warning messages. */
var NAMED_NOT_TERMINATED = 1;
var NUMERIC_NOT_TERMINATED = 2;
var NAMED_EMPTY = 3;
var NUMERIC_EMPTY = 4;
var NAMED_UNKNOWN = 5;
var NUMERIC_DISALLOWED = 6;
var NUMERIC_PROHIBITED = 7;

var NUMERIC_REFERENCE = 'Numeric character references';
var NAMED_REFERENCE = 'Named character references';
var TERMINATED = ' must be terminated by a semicolon';
var VOID = ' cannot be empty';

var MESSAGES = {};

MESSAGES[NAMED_NOT_TERMINATED] = NAMED_REFERENCE + TERMINATED;
MESSAGES[NUMERIC_NOT_TERMINATED] = NUMERIC_REFERENCE + TERMINATED;
MESSAGES[NAMED_EMPTY] = NAMED_REFERENCE + VOID;
MESSAGES[NUMERIC_EMPTY] = NUMERIC_REFERENCE + VOID;
MESSAGES[NAMED_UNKNOWN] = NAMED_REFERENCE + ' must be known';
MESSAGES[NUMERIC_DISALLOWED] = NUMERIC_REFERENCE + ' cannot be disallowed';
MESSAGES[NUMERIC_PROHIBITED] = NUMERIC_REFERENCE + ' cannot be outside the ' +
    'permissible Unicode range';

/* Wrap to ensure clean parameters are given to `parse`. */
function wrapper(value, options) {
  var settings = {};
  var option;
  var key;

  if (!options) {
    options = {};
  }

  for (key in defaults) {
    option = options[key];
    settings[key] = option === null || option === undefined ? defaults[key] : option;
  }

  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }

  return parse(value, settings);
}

/* Parse entities. */
function parse(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = EMPTY;
  var result = [];
  var entityCharacters;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type;
  var test;
  var prev;
  var next;
  var diff;
  var end;

  /* Cache the current point. */
  prev = now();

  /* Wrap `handleWarning`. */
  warning = handleWarning ? parseError : noop;

  /* Ensure the algorithm walks over the first character
   * and the end (inclusive). */
  index--;
  length++;

  while (++index < length) {
    /* If the previous character was a newline. */
    if (character === NEWLINE) {
      column = indent[lines] || 1;
    }

    character = at(index);

    /* Handle anything other than an ampersand,
     * including newlines and EOF. */
    if (character !== AMPERSAND) {
      if (character === NEWLINE) {
        line++;
        lines++;
        column = 0;
      }

      if (character) {
        queue += character;
        column++;
      } else {
        flush();
      }
    } else {
      following = at(index + 1);

      /* The behaviour depends on the identity of the next
       * character. */
      if (
        following === TAB ||
        following === NEWLINE ||
        following === FORM_FEED ||
        following === SPACE ||
        following === LESS_THAN ||
        following === AMPERSAND ||
        following === EMPTY ||
        (additional && following === additional)
      ) {
        /* Not a character reference. No characters
         * are consumed, and nothing is returned.
         * This is not an error, either. */
        queue += character;
        column++;

        continue;
      }

      start = index + 1;
      begin = start;
      end = start;

      /* Numerical entity. */
      if (following !== OCTOTHORP) {
        type = NAMED;
      } else {
        end = ++begin;

        /* The behaviour further depends on the
         * character after the U+0023 NUMBER SIGN. */
        following = at(end);

        if (following === X_LOWER || following === X_UPPER) {
          /* ASCII hex digits. */
          type = HEXADECIMAL;
          end = ++begin;
        } else {
          /* ASCII digits. */
          type = DECIMAL;
        }
      }

      entityCharacters = EMPTY;
      entity = EMPTY;
      characters = EMPTY;
      test = TESTS[type];
      end--;

      while (++end < length) {
        following = at(end);

        if (!test(following)) {
          break;
        }

        characters += following;

        /* Check if we can match a legacy named
         * reference.  If so, we cache that as the
         * last viable named reference.  This
         * ensures we do not need to walk backwards
         * later. */
        if (type === NAMED && own.call(legacy, characters)) {
          entityCharacters = characters;
          entity = legacy[characters];
        }
      }

      terminated = at(end) === SEMICOLON;

      if (terminated) {
        end++;

        if (type === NAMED && own.call(characterEntities, characters)) {
          entityCharacters = characters;
          entity = characterEntities[characters];
        }
      }

      diff = 1 + end - start;

      if (!terminated && !nonTerminated) {
        /* Empty. */
      } else if (!characters) {
        /* An empty (possible) entity is valid, unless
         * its numeric (thus an ampersand followed by
         * an octothorp). */
        if (type !== NAMED) {
          warning(NUMERIC_EMPTY, diff);
        }
      } else if (type === NAMED) {
        /* An ampersand followed by anything
         * unknown, and not terminated, is invalid. */
        if (terminated && !entity) {
          warning(NAMED_UNKNOWN, 1);
        } else {
          /* If theres something after an entity
           * name which is not known, cap the
           * reference. */
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }

          /* If the reference is not terminated,
           * warn. */
          if (!terminated) {
            reason = entityCharacters ?
              NAMED_NOT_TERMINATED :
              NAMED_EMPTY;

            if (!settings.attribute) {
              warning(reason, diff);
            } else {
              following = at(end);

              if (following === EQUAL) {
                warning(reason, diff);
                entity = null;
              } else if (alphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            }
          }
        }

        reference = entity;
      } else {
        if (!terminated) {
          /* All non-terminated numeric entities are
           * not rendered, and trigger a warning. */
          warning(NUMERIC_NOT_TERMINATED, diff);
        }

        /* When terminated and number, parse as
         * either hexadecimal or decimal. */
        reference = parseInt(characters, BASE[type]);

        /* Trigger a warning when the parsed number
         * is prohibited, and replace with
         * replacement character. */
        if (isProhibited(reference)) {
          warning(NUMERIC_PROHIBITED, diff);

          reference = REPLACEMENT;
        } else if (reference in invalid) {
          /* Trigger a warning when the parsed number
           * is disallowed, and replace by an
           * alternative. */
          warning(NUMERIC_DISALLOWED, diff);

          reference = invalid[reference];
        } else {
          /* Parse the number. */
          output = EMPTY;

          /* Trigger a warning when the parsed
           * number should not be used. */
          if (isWarning(reference)) {
            warning(NUMERIC_DISALLOWED, diff);
          }

          /* Stringify the number. */
          if (reference > 0xFFFF) {
            reference -= 0x10000;
            output += fromCharCode((reference >>> (10 & 0x3FF)) | 0xD800);
            reference = 0xDC00 | (reference & 0x3FF);
          }

          reference = output + fromCharCode(reference);
        }
      }

      /* If we could not find a reference, queue the
       * checked characters (as normal characters),
       * and move the pointer to their end. This is
       * possible because we can be certain neither
       * newlines nor ampersands are included. */
      if (!reference) {
        characters = value.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index = end - 1;
      } else {
        /* Found it! First eat the queued
         * characters as normal text, then eat
         * an entity. */
        flush();

        prev = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now();
        next.offset++;

        if (handleReference) {
          handleReference.call(referenceContext, reference, {
            start: prev,
            end: next
          }, value.slice(start - 1, end));
        }

        prev = next;
      }
    }
  }

  /* Return the reduced nodes, and any possible warnings. */
  return result.join(EMPTY);

  /* Get current position. */
  function now() {
    return {
      line: line,
      column: column,
      offset: index + (pos.offset || 0)
    };
  }

  /* ‚ÄúThrow‚Äù a parse-error: a warning. */
  function parseError(code, offset) {
    var position = now();

    position.column += offset;
    position.offset += offset;

    handleWarning.call(warningContext, MESSAGES[code], position, code);
  }

  /* Get character at position. */
  function at(position) {
    return value.charAt(position);
  }

  /* Flush `queue` (normal text). Macro invoked before
   * each entity and at the end of `value`.
   * Does nothing when `queue` is empty. */
  function flush() {
    if (queue) {
      result.push(queue);

      if (handleText) {
        handleText.call(textContext, queue, {
          start: prev,
          end: now()
        });
      }

      queue = EMPTY;
    }
  }
}

/* Check if `character` is outside the permissible
 * unicode range. */
function isProhibited(code) {
  return (code >= 0xD800 && code <= 0xDFFF) || (code > 0x10FFFF);
}

/* Check if `character` is disallowed. */
function isWarning(code) {
  if (
    (code >= 0x0001 && code <= 0x0008) ||
    code === 0x000B ||
    (code >= 0x000D && code <= 0x001F) ||
    (code >= 0x007F && code <= 0x009F) ||
    (code >= 0xFDD0 && code <= 0xFDEF) ||
    (code & 0xFFFF) === 0xFFFF ||
    (code & 0xFFFF) === 0xFFFE
  ) {
    return true;
  }

  return false;
}

},{"character-entities":7,"character-entities-legacy":6,"character-reference-invalid":8,"is-alphanumerical":14,"is-decimal":16,"is-hexadecimal":17}],26:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":27}],27:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],28:[function(require,module,exports){
'use strict';

var unherit = require('unherit');
var xtend = require('xtend');
var Parser = require('./lib/parser.js');

module.exports = parse;
parse.Parser = Parser;

function parse(options) {
  var Local = unherit(Parser);
  Local.prototype.options = xtend(Local.prototype.options, this.data('settings'), options);
  this.Parser = Local;
}

},{"./lib/parser.js":42,"unherit":130,"xtend":140}],29:[function(require,module,exports){
module.exports=[
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "meta",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "pre",
  "section",
  "source",
  "title",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
]

},{}],30:[function(require,module,exports){
'use strict';

var entities = require('parse-entities');

module.exports = factory;

/* Factory to create an entity decoder. */
function factory(ctx) {
  decoder.raw = decodeRaw;

  return decoder;

  /* Normalize `position` to add an `indent`. */
  function normalize(position) {
    var offsets = ctx.offset;
    var line = position.line;
    var result = [];

    while (++line) {
      if (!(line in offsets)) {
        break;
      }

      result.push((offsets[line] || 0) + 1);
    }

    return {
      start: position,
      indent: result
    };
  }

  /* Handle a warning.
   * See https://github.com/wooorm/parse-entities
   * for the warnings. */
  function handleWarning(reason, position, code) {
    if (code === 3) {
      return;
    }

    ctx.file.message(reason, position);
  }

  /* Decode `value` (at `position`) into text-nodes. */
  function decoder(value, position, handler) {
    entities(value, {
      position: normalize(position),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }

  /* Decode `value` (at `position`) into a string. */
  function decodeRaw(value, position) {
    return entities(value, {
      position: normalize(position),
      warning: handleWarning
    });
  }
}

},{"parse-entities":25}],31:[function(require,module,exports){
'use strict';

module.exports = {
  position: true,
  gfm: true,
  commonmark: false,
  footnotes: false,
  pedantic: false,
  blocks: require('./block-elements.json')
};

},{"./block-elements.json":29}],32:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  var index = value.indexOf('\n', fromIndex);

  while (index > fromIndex) {
    if (value.charAt(index - 1) !== ' ') {
      break;
    }

    index--;
  }

  return index;
}

},{}],33:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  return value.indexOf('`', fromIndex);
}

},{}],34:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  return value.indexOf('~~', fromIndex);
}

},{}],35:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  var asterisk = value.indexOf('*', fromIndex);
  var underscore = value.indexOf('_', fromIndex);

  if (underscore === -1) {
    return asterisk;
  }

  if (asterisk === -1) {
    return underscore;
  }

  return underscore < asterisk ? underscore : asterisk;
}

},{}],36:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  return value.indexOf('\\', fromIndex);
}

},{}],37:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  var link = value.indexOf('[', fromIndex);
  var image = value.indexOf('![', fromIndex);

  if (image === -1) {
    return link;
  }

  /* Link can never be `-1` if an image is found, so we don‚Äôt need
   * to check for that :) */
  return link < image ? link : image;
}

},{}],38:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  var asterisk = value.indexOf('**', fromIndex);
  var underscore = value.indexOf('__', fromIndex);

  if (underscore === -1) {
    return asterisk;
  }

  if (asterisk === -1) {
    return underscore;
  }

  return underscore < asterisk ? underscore : asterisk;
}

},{}],39:[function(require,module,exports){
'use strict';

module.exports = locate;

function locate(value, fromIndex) {
  return value.indexOf('<', fromIndex);
}

},{}],40:[function(require,module,exports){
'use strict';

module.exports = locate;

var PROTOCOLS = ['https://', 'http://', 'mailto:'];

function locate(value, fromIndex) {
  var length = PROTOCOLS.length;
  var index = -1;
  var min = -1;
  var position;

  if (!this.options.gfm) {
    return -1;
  }

  while (++index < length) {
    position = value.indexOf(PROTOCOLS[index], fromIndex);

    if (position !== -1 && (position < min || min === -1)) {
      min = position;
    }
  }

  return min;
}

},{}],41:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var removePosition = require('unist-util-remove-position');

module.exports = parse;

var C_NEWLINE = '\n';
var EXPRESSION_LINE_BREAKS = /\r\n|\r/g;

/* Parse the bound file. */
function parse() {
  var self = this;
  var value = String(self.file);
  var start = {line: 1, column: 1, offset: 0};
  var content = xtend(start);
  var node;

  /* Clean non-unix newlines: `\r\n` and `\r` are all
   * changed to `\n`.  This should not affect positional
   * information. */
  value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE);

  if (value.charCodeAt(0) === 0xFEFF) {
    value = value.slice(1);

    content.column++;
    content.offset++;
  }

  node = {
    type: 'root',
    children: self.tokenizeBlock(value, content),
    position: {
      start: start,
      end: self.eof || xtend(start)
    }
  };

  if (!self.options.position) {
    removePosition(node, true);
  }

  return node;
}

},{"unist-util-remove-position":133,"xtend":140}],42:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var toggle = require('state-toggle');
var vfileLocation = require('vfile-location');
var unescape = require('./unescape');
var decode = require('./decode');
var tokenizer = require('./tokenizer');

module.exports = Parser;

function Parser(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = xtend(this.options);
  this.setOptions({});

  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;

  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = unescape(this, 'escape');
  this.decode = decode(this);
}

var proto = Parser.prototype;

/* Expose core. */
proto.setOptions = require('./set-options');
proto.parse = require('./parse');

/* Expose `defaults`. */
proto.options = require('./defaults');

/* Enter and exit helpers. */
proto.exitStart = toggle('atStart', true);
proto.enterList = toggle('inList', false);
proto.enterLink = toggle('inLink', false);
proto.enterBlock = toggle('inBlock', false);

/* Nodes that can interupt a paragraph:
 *
 * ```markdown
 * A paragraph, followed by a thematic break.
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the paragraph. */
proto.interruptParagraph = [
  ['thematicBreak'],
  ['atxHeading'],
  ['fencedCode'],
  ['blockquote'],
  ['html'],
  ['setextHeading', {commonmark: false}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Nodes that can interupt a list:
 *
 * ```markdown
 * - One
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the list. */
proto.interruptList = [
  ['fencedCode', {pedantic: false}],
  ['thematicBreak', {pedantic: false}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Nodes that can interupt a blockquote:
 *
 * ```markdown
 * > A paragraph.
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the blockquote. */
proto.interruptBlockquote = [
  ['indentedCode', {commonmark: true}],
  ['fencedCode', {commonmark: true}],
  ['atxHeading', {commonmark: true}],
  ['setextHeading', {commonmark: true}],
  ['thematicBreak', {commonmark: true}],
  ['html', {commonmark: true}],
  ['list', {commonmark: true}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Handlers. */
proto.blockTokenizers = {
  newline: require('./tokenize/newline'),
  indentedCode: require('./tokenize/code-indented'),
  fencedCode: require('./tokenize/code-fenced'),
  blockquote: require('./tokenize/blockquote'),
  atxHeading: require('./tokenize/heading-atx'),
  thematicBreak: require('./tokenize/thematic-break'),
  list: require('./tokenize/list'),
  setextHeading: require('./tokenize/heading-setext'),
  html: require('./tokenize/html-block'),
  footnote: require('./tokenize/footnote-definition'),
  definition: require('./tokenize/definition'),
  table: require('./tokenize/table'),
  paragraph: require('./tokenize/paragraph')
};

proto.inlineTokenizers = {
  escape: require('./tokenize/escape'),
  autoLink: require('./tokenize/auto-link'),
  url: require('./tokenize/url'),
  html: require('./tokenize/html-inline'),
  link: require('./tokenize/link'),
  reference: require('./tokenize/reference'),
  strong: require('./tokenize/strong'),
  emphasis: require('./tokenize/emphasis'),
  deletion: require('./tokenize/delete'),
  code: require('./tokenize/code-inline'),
  break: require('./tokenize/break'),
  text: require('./tokenize/text')
};

/* Expose precedence. */
proto.blockMethods = keys(proto.blockTokenizers);
proto.inlineMethods = keys(proto.inlineTokenizers);

/* Tokenizers. */
proto.tokenizeBlock = tokenizer('block');
proto.tokenizeInline = tokenizer('inline');
proto.tokenizeFactory = tokenizer;

/* Get all keys in `value`. */
function keys(value) {
  var result = [];
  var key;

  for (key in value) {
    result.push(key);
  }

  return result;
}

},{"./decode":30,"./defaults":31,"./parse":41,"./set-options":43,"./tokenize/auto-link":44,"./tokenize/blockquote":45,"./tokenize/break":46,"./tokenize/code-fenced":47,"./tokenize/code-indented":48,"./tokenize/code-inline":49,"./tokenize/definition":50,"./tokenize/delete":51,"./tokenize/emphasis":52,"./tokenize/escape":53,"./tokenize/footnote-definition":54,"./tokenize/heading-atx":55,"./tokenize/heading-setext":56,"./tokenize/html-block":57,"./tokenize/html-inline":58,"./tokenize/link":59,"./tokenize/list":60,"./tokenize/newline":61,"./tokenize/paragraph":62,"./tokenize/reference":63,"./tokenize/strong":64,"./tokenize/table":65,"./tokenize/text":66,"./tokenize/thematic-break":67,"./tokenize/url":68,"./tokenizer":69,"./unescape":70,"state-toggle":123,"vfile-location":136,"xtend":140}],43:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var escapes = require('markdown-escapes');
var defaults = require('./defaults');

module.exports = setOptions;

function setOptions(options) {
  var self = this;
  var current = self.options;
  var key;
  var value;

  if (options == null) {
    options = {};
  } else if (typeof options === 'object') {
    options = xtend(options);
  } else {
    throw new Error(
      'Invalid value `' + options + '` ' +
      'for setting `options`'
    );
  }

  for (key in defaults) {
    value = options[key];

    if (value == null) {
      value = current[key];
    }

    if (
      (key !== 'blocks' && typeof value !== 'boolean') ||
      (key === 'blocks' && typeof value !== 'object')
    ) {
      throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');
    }

    options[key] = value;
  }

  self.options = options;
  self.escape = escapes(options);

  return self;
}

},{"./defaults":31,"markdown-escapes":22,"xtend":140}],44:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var decode = require('parse-entities');
var locate = require('../locate/tag');

module.exports = autoLink;
autoLink.locator = locate;
autoLink.notInLink = true;

var C_LT = '<';
var C_GT = '>';
var C_AT_SIGN = '@';
var C_SLASH = '/';
var MAILTO = 'mailto:';
var MAILTO_LENGTH = MAILTO.length;

/* Tokenise a link. */
function autoLink(eat, value, silent) {
  var self;
  var subvalue;
  var length;
  var index;
  var queue;
  var character;
  var hasAtCharacter;
  var link;
  var now;
  var content;
  var tokenize;
  var exit;

  if (value.charAt(0) !== C_LT) {
    return;
  }

  self = this;
  subvalue = '';
  length = value.length;
  index = 0;
  queue = '';
  hasAtCharacter = false;
  link = '';

  index++;
  subvalue = C_LT;

  while (index < length) {
    character = value.charAt(index);

    if (
      whitespace(character) ||
      character === C_GT ||
      character === C_AT_SIGN ||
      (character === ':' && value.charAt(index + 1) === C_SLASH)
    ) {
      break;
    }

    queue += character;
    index++;
  }

  if (!queue) {
    return;
  }

  link += queue;
  queue = '';

  character = value.charAt(index);
  link += character;
  index++;

  if (character === C_AT_SIGN) {
    hasAtCharacter = true;
  } else {
    if (
      character !== ':' ||
      value.charAt(index + 1) !== C_SLASH
    ) {
      return;
    }

    link += C_SLASH;
    index++;
  }

  while (index < length) {
    character = value.charAt(index);

    if (whitespace(character) || character === C_GT) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  if (!queue || character !== C_GT) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  link += queue;
  content = link;
  subvalue += link + character;
  now = eat.now();
  now.column++;
  now.offset++;

  if (hasAtCharacter) {
    if (link.slice(0, MAILTO_LENGTH).toLowerCase() === MAILTO) {
      content = content.substr(MAILTO_LENGTH);
      now.column += MAILTO_LENGTH;
      now.offset += MAILTO_LENGTH;
    } else {
      link = MAILTO + link;
    }
  }

  /* Temporarily remove support for escapes in autolinks. */
  tokenize = self.inlineTokenizers.escape;
  self.inlineTokenizers.escape = null;
  exit = self.enterLink();

  content = self.tokenizeInline(content, now);

  self.inlineTokenizers.escape = tokenize;
  exit();

  return eat(subvalue)({
    type: 'link',
    title: null,
    url: decode(link),
    children: content
  });
}

},{"../locate/tag":39,"is-whitespace-character":19,"parse-entities":25}],45:[function(require,module,exports){
'use strict';

var trim = require('trim');
var interrupt = require('../util/interrupt');

module.exports = blockquote;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_GT = '>';

/* Tokenise a blockquote. */
function blockquote(eat, value, silent) {
  var self = this;
  var offsets = self.offset;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptBlockquote;
  var now = eat.now();
  var currentLine = now.line;
  var length = value.length;
  var values = [];
  var contents = [];
  var indents = [];
  var add;
  var index = 0;
  var character;
  var rest;
  var nextIndex;
  var content;
  var line;
  var startIndex;
  var prefixed;
  var exit;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      break;
    }

    index++;
  }

  if (value.charAt(index) !== C_GT) {
    return;
  }

  if (silent) {
    return true;
  }

  index = 0;

  while (index < length) {
    nextIndex = value.indexOf(C_NEWLINE, index);
    startIndex = index;
    prefixed = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE && character !== C_TAB) {
        break;
      }

      index++;
    }

    if (value.charAt(index) === C_GT) {
      index++;
      prefixed = true;

      if (value.charAt(index) === C_SPACE) {
        index++;
      }
    } else {
      index = startIndex;
    }

    content = value.slice(index, nextIndex);

    if (!prefixed && !trim(content)) {
      index = startIndex;
      break;
    }

    if (!prefixed) {
      rest = value.slice(index);

      /* Check if the following code contains a possible
       * block. */
      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {
        break;
      }
    }

    line = startIndex === index ? content : value.slice(startIndex, nextIndex);

    indents.push(index - startIndex);
    values.push(line);
    contents.push(content);

    index = nextIndex + 1;
  }

  index = -1;
  length = indents.length;
  add = eat(values.join(C_NEWLINE));

  while (++index < length) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
    currentLine++;
  }

  exit = self.enterBlock();
  contents = self.tokenizeBlock(contents.join(C_NEWLINE), now);
  exit();

  return add({
    type: 'blockquote',
    children: contents
  });
}

},{"../util/interrupt":73,"trim":128}],46:[function(require,module,exports){
'use strict';

var locate = require('../locate/break');

module.exports = hardBreak;
hardBreak.locator = locate;

var MIN_BREAK_LENGTH = 2;

function hardBreak(eat, value, silent) {
  var length = value.length;
  var index = -1;
  var queue = '';
  var character;

  while (++index < length) {
    character = value.charAt(index);

    if (character === '\n') {
      if (index < MIN_BREAK_LENGTH) {
        return;
      }

      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      queue += character;

      return eat(queue)({type: 'break'});
    }

    if (character !== ' ') {
      return;
    }

    queue += character;
  }
}

},{"../locate/break":32}],47:[function(require,module,exports){
'use strict';

var trim = require('trim-trailing-lines');

module.exports = fencedCode;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_TILDE = '~';
var C_TICK = '`';

var MIN_FENCE_COUNT = 3;
var CODE_INDENT_COUNT = 4;

function fencedCode(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var length = value.length + 1;
  var index = 0;
  var subvalue = '';
  var fenceCount;
  var marker;
  var character;
  var flag;
  var queue;
  var content;
  var exdentedContent;
  var closing;
  var exdentedClosing;
  var indent;
  var now;

  if (!settings.gfm) {
    return;
  }

  /* Eat initial spacing. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      break;
    }

    subvalue += character;
    index++;
  }

  indent = index;

  /* Eat the fence. */
  character = value.charAt(index);

  if (character !== C_TILDE && character !== C_TICK) {
    return;
  }

  index++;
  marker = character;
  fenceCount = 1;
  subvalue += character;

  while (index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      break;
    }

    subvalue += character;
    fenceCount++;
    index++;
  }

  if (fenceCount < MIN_FENCE_COUNT) {
    return;
  }

  /* Eat spacing before flag. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      break;
    }

    subvalue += character;
    index++;
  }

  /* Eat flag. */
  flag = '';
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character === C_NEWLINE ||
      character === C_TILDE ||
      character === C_TICK
    ) {
      break;
    }

    if (character === C_SPACE || character === C_TAB) {
      queue += character;
    } else {
      flag += queue + character;
      queue = '';
    }

    index++;
  }

  character = value.charAt(index);

  if (character && character !== C_NEWLINE) {
    return;
  }

  if (silent) {
    return true;
  }

  now = eat.now();
  now.column += subvalue.length;
  now.offset += subvalue.length;

  subvalue += flag;
  flag = self.decode.raw(self.unescape(flag), now);

  if (queue) {
    subvalue += queue;
  }

  queue = '';
  closing = '';
  exdentedClosing = '';
  content = '';
  exdentedContent = '';

  /* Eat content. */
  while (index < length) {
    character = value.charAt(index);
    content += closing;
    exdentedContent += exdentedClosing;
    closing = '';
    exdentedClosing = '';

    if (character !== C_NEWLINE) {
      content += character;
      exdentedClosing += character;
      index++;
      continue;
    }

    /* Add the newline to `subvalue` if its the first
     * character.  Otherwise, add it to the `closing`
     * queue. */
    if (content) {
      closing += character;
      exdentedClosing += character;
    } else {
      subvalue += character;
    }

    queue = '';
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE) {
        break;
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue.slice(indent);

    if (queue.length >= CODE_INDENT_COUNT) {
      continue;
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== marker) {
        break;
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue;

    if (queue.length < fenceCount) {
      continue;
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE && character !== C_TAB) {
        break;
      }

      closing += character;
      exdentedClosing += character;
      index++;
    }

    if (!character || character === C_NEWLINE) {
      break;
    }
  }

  subvalue += content + closing;

  return eat(subvalue)({
    type: 'code',
    lang: flag || null,
    value: trim(exdentedContent)
  });
}

},{"trim-trailing-lines":127}],48:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');
var trim = require('trim-trailing-lines');

module.exports = indentedCode;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';

var CODE_INDENT_COUNT = 4;
var CODE_INDENT = repeat(C_SPACE, CODE_INDENT_COUNT);

/* Tokenise indented code. */
function indentedCode(eat, value, silent) {
  var index = -1;
  var length = value.length;
  var subvalue = '';
  var content = '';
  var subvalueQueue = '';
  var contentQueue = '';
  var character;
  var blankQueue;
  var indent;

  while (++index < length) {
    character = value.charAt(index);

    if (indent) {
      indent = false;

      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = '';
      contentQueue = '';

      if (character === C_NEWLINE) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;

        while (++index < length) {
          character = value.charAt(index);

          if (!character || character === C_NEWLINE) {
            contentQueue = character;
            subvalueQueue = character;
            break;
          }

          subvalue += character;
          content += character;
        }
      }
    } else if (
      character === C_SPACE &&
      value.charAt(index + 1) === character &&
      value.charAt(index + 2) === character &&
      value.charAt(index + 3) === character
    ) {
      subvalueQueue += CODE_INDENT;
      index += 3;
      indent = true;
    } else if (character === C_TAB) {
      subvalueQueue += character;
      indent = true;
    } else {
      blankQueue = '';

      while (character === C_TAB || character === C_SPACE) {
        blankQueue += character;
        character = value.charAt(++index);
      }

      if (character !== C_NEWLINE) {
        break;
      }

      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }

  if (content) {
    if (silent) {
      return true;
    }

    return eat(subvalue)({
      type: 'code',
      lang: null,
      value: trim(content)
    });
  }
}

},{"repeat-string":121,"trim-trailing-lines":127}],49:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var locate = require('../locate/code-inline');

module.exports = inlineCode;
inlineCode.locator = locate;

var C_TICK = '`';

/* Tokenise inline code. */
function inlineCode(eat, value, silent) {
  var length = value.length;
  var index = 0;
  var queue = '';
  var tickQueue = '';
  var contentQueue;
  var subqueue;
  var count;
  var openingCount;
  var subvalue;
  var character;
  var found;
  var next;

  while (index < length) {
    if (value.charAt(index) !== C_TICK) {
      break;
    }

    queue += C_TICK;
    index++;
  }

  if (!queue) {
    return;
  }

  subvalue = queue;
  openingCount = index;
  queue = '';
  next = value.charAt(index);
  count = 0;

  while (index < length) {
    character = next;
    next = value.charAt(index + 1);

    if (character === C_TICK) {
      count++;
      tickQueue += character;
    } else {
      count = 0;
      queue += character;
    }

    if (count && next !== C_TICK) {
      if (count === openingCount) {
        subvalue += queue + tickQueue;
        found = true;
        break;
      }

      queue += tickQueue;
      tickQueue = '';
    }

    index++;
  }

  if (!found) {
    if (openingCount % 2 !== 0) {
      return;
    }

    queue = '';
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  contentQueue = '';
  subqueue = '';
  length = queue.length;
  index = -1;

  while (++index < length) {
    character = queue.charAt(index);

    if (whitespace(character)) {
      subqueue += character;
      continue;
    }

    if (subqueue) {
      if (contentQueue) {
        contentQueue += subqueue;
      }

      subqueue = '';
    }

    contentQueue += character;
  }

  return eat(subvalue)({
    type: 'inlineCode',
    value: contentQueue
  });
}

},{"../locate/code-inline":33,"is-whitespace-character":19}],50:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var normalize = require('../util/normalize');

module.exports = definition;
definition.notInList = true;
definition.notInBlock = true;

var C_DOUBLE_QUOTE = '"';
var C_SINGLE_QUOTE = '\'';
var C_BACKSLASH = '\\';
var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';
var C_PAREN_OPEN = '(';
var C_PAREN_CLOSE = ')';
var C_COLON = ':';
var C_LT = '<';
var C_GT = '>';

function definition(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test;
  var identifier;
  var url;
  var title;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (character !== C_BRACKET_OPEN) {
    return;
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE) {
      break;
    } else if (character === C_BACKSLASH) {
      queue += character;
      index++;
      character = value.charAt(index);
    }

    queue += character;
    index++;
  }

  if (
    !queue ||
    value.charAt(index) !== C_BRACKET_CLOSE ||
    value.charAt(index + 1) !== C_COLON
  ) {
    return;
  }

  identifier = queue;
  subvalue += queue + C_BRACKET_CLOSE + C_COLON;
  index = subvalue.length;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character !== C_TAB &&
      character !== C_SPACE &&
      character !== C_NEWLINE
    ) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);
  queue = '';
  beforeURL = subvalue;

  if (character === C_LT) {
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (!isEnclosedURLCharacter(character)) {
        break;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character === isEnclosedURLCharacter.delimiter) {
      subvalue += C_LT + queue + character;
      index++;
    } else {
      if (commonmark) {
        return;
      }

      index -= queue.length + 1;
      queue = '';
    }
  }

  if (!queue) {
    while (index < length) {
      character = value.charAt(index);

      if (!isUnclosedURLCharacter(character)) {
        break;
      }

      queue += character;
      index++;
    }

    subvalue += queue;
  }

  if (!queue) {
    return;
  }

  url = queue;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character !== C_TAB &&
      character !== C_SPACE &&
      character !== C_NEWLINE
    ) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  test = null;

  if (character === C_DOUBLE_QUOTE) {
    test = C_DOUBLE_QUOTE;
  } else if (character === C_SINGLE_QUOTE) {
    test = C_SINGLE_QUOTE;
  } else if (character === C_PAREN_OPEN) {
    test = C_PAREN_CLOSE;
  }

  if (!test) {
    queue = '';
    index = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index = subvalue.length;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character === test) {
        break;
      }

      if (character === C_NEWLINE) {
        index++;
        character = value.charAt(index);

        if (character === C_NEWLINE || character === test) {
          return;
        }

        queue += C_NEWLINE;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character !== test) {
      return;
    }

    beforeTitle = subvalue;
    subvalue += queue + character;
    index++;
    title = queue;
    queue = '';
  } else {
    return;
  }

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB && character !== C_SPACE) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (!character || character === C_NEWLINE) {
    if (silent) {
      return true;
    }

    beforeURL = eat(beforeURL).test().end;
    url = self.decode.raw(self.unescape(url), beforeURL);

    if (title) {
      beforeTitle = eat(beforeTitle).test().end;
      title = self.decode.raw(self.unescape(title), beforeTitle);
    }

    return eat(subvalue)({
      type: 'definition',
      identifier: normalize(identifier),
      title: title || null,
      url: url
    });
  }
}

/* Check if `character` can be inside an enclosed URI. */
function isEnclosedURLCharacter(character) {
  return character !== C_GT &&
    character !== C_BRACKET_OPEN &&
    character !== C_BRACKET_CLOSE;
}

isEnclosedURLCharacter.delimiter = C_GT;

/* Check if `character` can be inside an unclosed URI. */
function isUnclosedURLCharacter(character) {
  return character !== C_BRACKET_OPEN &&
    character !== C_BRACKET_CLOSE &&
    !whitespace(character);
}

},{"../util/normalize":74,"is-whitespace-character":19}],51:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var locate = require('../locate/delete');

module.exports = strikethrough;
strikethrough.locator = locate;

var C_TILDE = '~';
var DOUBLE = '~~';

function strikethrough(eat, value, silent) {
  var self = this;
  var character = '';
  var previous = '';
  var preceding = '';
  var subvalue = '';
  var index;
  var length;
  var now;

  if (
    !self.options.gfm ||
    value.charAt(0) !== C_TILDE ||
    value.charAt(1) !== C_TILDE ||
    whitespace(value.charAt(2))
  ) {
    return;
  }

  index = 1;
  length = value.length;
  now = eat.now();
  now.column += 2;
  now.offset += 2;

  while (++index < length) {
    character = value.charAt(index);

    if (
      character === C_TILDE &&
      previous === C_TILDE &&
      (!preceding || !whitespace(preceding))
    ) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      return eat(DOUBLE + subvalue + DOUBLE)({
        type: 'delete',
        children: self.tokenizeInline(subvalue, now)
      });
    }

    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}

},{"../locate/delete":34,"is-whitespace-character":19}],52:[function(require,module,exports){
'use strict';

var trim = require('trim');
var word = require('is-word-character');
var whitespace = require('is-whitespace-character');
var locate = require('../locate/emphasis');

module.exports = emphasis;
emphasis.locator = locate;

var C_ASTERISK = '*';
var C_UNDERSCORE = '_';

function emphasis(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var prev;

  if (character !== C_ASTERISK && character !== C_UNDERSCORE) {
    return;
  }

  pedantic = self.options.pedantic;
  subvalue = character;
  marker = character;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && whitespace(value.charAt(index))) {
    return;
  }

  while (index < length) {
    prev = character;
    character = value.charAt(index);

    if (character === marker && (!pedantic || !whitespace(prev))) {
      character = value.charAt(++index);

      if (character !== marker) {
        if (!trim(queue) || prev === marker) {
          return;
        }

        if (!pedantic && marker === C_UNDERSCORE && word(character)) {
          queue += marker;
          continue;
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true;
        }

        now = eat.now();
        now.column++;
        now.offset++;

        return eat(subvalue + queue + marker)({
          type: 'emphasis',
          children: self.tokenizeInline(queue, now)
        });
      }

      queue += marker;
    }

    if (!pedantic && character === '\\') {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

},{"../locate/emphasis":35,"is-whitespace-character":19,"is-word-character":20,"trim":128}],53:[function(require,module,exports){
'use strict';

var locate = require('../locate/escape');

module.exports = escape;
escape.locator = locate;

function escape(eat, value, silent) {
  var self = this;
  var character;
  var node;

  if (value.charAt(0) === '\\') {
    character = value.charAt(1);

    if (self.escape.indexOf(character) !== -1) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      if (character === '\n') {
        node = {type: 'break'};
      } else {
        node = {
          type: 'text',
          value: character
        };
      }

      return eat('\\' + character)(node);
    }
  }
}

},{"../locate/escape":36}],54:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var normalize = require('../util/normalize');

module.exports = footnoteDefinition;
footnoteDefinition.notInList = true;
footnoteDefinition.notInBlock = true;

var C_BACKSLASH = '\\';
var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';
var C_CARET = '^';
var C_COLON = ':';

var EXPRESSION_INITIAL_TAB = /^( {4}|\t)?/gm;

function footnoteDefinition(eat, value, silent) {
  var self = this;
  var offsets = self.offset;
  var index;
  var length;
  var subvalue;
  var now;
  var currentLine;
  var content;
  var queue;
  var subqueue;
  var character;
  var identifier;
  var add;
  var exit;

  if (!self.options.footnotes) {
    return;
  }

  index = 0;
  length = value.length;
  subvalue = '';
  now = eat.now();
  currentLine = now.line;

  while (index < length) {
    character = value.charAt(index);

    if (!whitespace(character)) {
      break;
    }

    subvalue += character;
    index++;
  }

  if (
    value.charAt(index) !== C_BRACKET_OPEN ||
    value.charAt(index + 1) !== C_CARET
  ) {
    return;
  }

  subvalue += C_BRACKET_OPEN + C_CARET;
  index = subvalue.length;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE) {
      break;
    } else if (character === C_BACKSLASH) {
      queue += character;
      index++;
      character = value.charAt(index);
    }

    queue += character;
    index++;
  }

  if (
    !queue ||
    value.charAt(index) !== C_BRACKET_CLOSE ||
    value.charAt(index + 1) !== C_COLON
  ) {
    return;
  }

  if (silent) {
    return true;
  }

  identifier = normalize(queue);
  subvalue += queue + C_BRACKET_CLOSE + C_COLON;
  index = subvalue.length;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB && character !== C_SPACE) {
      break;
    }

    subvalue += character;
    index++;
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  queue = '';
  content = '';
  subqueue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_NEWLINE) {
      subqueue = character;
      index++;

      while (index < length) {
        character = value.charAt(index);

        if (character !== C_NEWLINE) {
          break;
        }

        subqueue += character;
        index++;
      }

      queue += subqueue;
      subqueue = '';

      while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE) {
          break;
        }

        subqueue += character;
        index++;
      }

      if (subqueue.length === 0) {
        break;
      }

      queue += subqueue;
    }

    if (queue) {
      content += queue;
      queue = '';
    }

    content += character;
    index++;
  }

  subvalue += content;

  content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {
    offsets[currentLine] = (offsets[currentLine] || 0) + line.length;
    currentLine++;

    return '';
  });

  add = eat(subvalue);

  exit = self.enterBlock();
  content = self.tokenizeBlock(content, now);
  exit();

  return add({
    type: 'footnoteDefinition',
    identifier: identifier,
    children: content
  });
}

},{"../util/normalize":74,"is-whitespace-character":19}],55:[function(require,module,exports){
'use strict';

module.exports = atxHeading;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_HASH = '#';

var MAX_ATX_COUNT = 6;

function atxHeading(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var length = value.length + 1;
  var index = -1;
  var now = eat.now();
  var subvalue = '';
  var content = '';
  var character;
  var queue;
  var depth;

  /* Eat initial spacing. */
  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      index--;
      break;
    }

    subvalue += character;
  }

  /* Eat hashes. */
  depth = 0;

  while (++index <= length) {
    character = value.charAt(index);

    if (character !== C_HASH) {
      index--;
      break;
    }

    subvalue += character;
    depth++;
  }

  if (depth > MAX_ATX_COUNT) {
    return;
  }

  if (
    !depth ||
    (!settings.pedantic && value.charAt(index + 1) === C_HASH)
  ) {
    return;
  }

  length = value.length + 1;

  /* Eat intermediate white-space. */
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE && character !== C_TAB) {
      index--;
      break;
    }

    queue += character;
  }

  /* Exit when not in pedantic mode without spacing. */
  if (
    !settings.pedantic &&
    queue.length === 0 &&
    character &&
    character !== C_NEWLINE
  ) {
    return;
  }

  if (silent) {
    return true;
  }

  /* Eat content. */
  subvalue += queue;
  queue = '';
  content = '';

  while (++index < length) {
    character = value.charAt(index);

    if (!character || character === C_NEWLINE) {
      break;
    }

    if (
      character !== C_SPACE &&
      character !== C_TAB &&
      character !== C_HASH
    ) {
      content += queue + character;
      queue = '';
      continue;
    }

    while (character === C_SPACE || character === C_TAB) {
      queue += character;
      character = value.charAt(++index);
    }

    while (character === C_HASH) {
      queue += character;
      character = value.charAt(++index);
    }

    while (character === C_SPACE || character === C_TAB) {
      queue += character;
      character = value.charAt(++index);
    }

    index--;
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  return eat(subvalue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  });
}

},{}],56:[function(require,module,exports){
'use strict';

module.exports = setextHeading;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_EQUALS = '=';
var C_DASH = '-';

var MAX_HEADING_INDENT = 3;

/* Map of characters which can be used to mark setext
 * headers, mapping to their corresponding depth. */
var SETEXT_MARKERS = {};

SETEXT_MARKERS[C_EQUALS] = 1;
SETEXT_MARKERS[C_DASH] = 2;

function setextHeading(eat, value, silent) {
  var self = this;
  var now = eat.now();
  var length = value.length;
  var index = -1;
  var subvalue = '';
  var content;
  var queue;
  var character;
  var marker;
  var depth;

  /* Eat initial indentation. */
  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {
      index--;
      break;
    }

    subvalue += character;
  }

  /* Eat content. */
  content = '';
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === C_NEWLINE) {
      index--;
      break;
    }

    if (character === C_SPACE || character === C_TAB) {
      queue += character;
    } else {
      content += queue + character;
      queue = '';
    }
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  /* Ensure the content is followed by a newline and a
   * valid marker. */
  character = value.charAt(++index);
  marker = value.charAt(++index);

  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {
    return;
  }

  subvalue += character;

  /* Eat Setext-line. */
  queue = marker;
  depth = SETEXT_MARKERS[marker];

  while (++index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      if (character !== C_NEWLINE) {
        return;
      }

      index--;
      break;
    }

    queue += character;
  }

  if (silent) {
    return true;
  }

  return eat(subvalue + queue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  });
}

},{}],57:[function(require,module,exports){
'use strict';

var openCloseTag = require('../util/html').openCloseTag;

module.exports = blockHTML;

var C_TAB = '\t';
var C_SPACE = ' ';
var C_NEWLINE = '\n';
var C_LT = '<';

function blockHTML(eat, value, silent) {
  var self = this;
  var blocks = self.options.blocks;
  var length = value.length;
  var index = 0;
  var next;
  var line;
  var offset;
  var character;
  var count;
  var sequence;
  var subvalue;

  var sequences = [
    [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Za-z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true],
    [new RegExp(openCloseTag.source + '\\s*$'), /^$/, false]
  ];

  /* Eat initial spacing. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB && character !== C_SPACE) {
      break;
    }

    index++;
  }

  if (value.charAt(index) !== C_LT) {
    return;
  }

  next = value.indexOf(C_NEWLINE, index + 1);
  next = next === -1 ? length : next;
  line = value.slice(index, next);
  offset = -1;
  count = sequences.length;

  while (++offset < count) {
    if (sequences[offset][0].test(line)) {
      sequence = sequences[offset];
      break;
    }
  }

  if (!sequence) {
    return;
  }

  if (silent) {
    return sequence[2];
  }

  index = next;

  if (!sequence[1].test(line)) {
    while (index < length) {
      next = value.indexOf(C_NEWLINE, index + 1);
      next = next === -1 ? length : next;
      line = value.slice(index + 1, next);

      if (sequence[1].test(line)) {
        if (line) {
          index = next;
        }

        break;
      }

      index = next;
    }
  }

  subvalue = value.slice(0, index);

  return eat(subvalue)({type: 'html', value: subvalue});
}

},{"../util/html":72}],58:[function(require,module,exports){
'use strict';

var alphabetical = require('is-alphabetical');
var locate = require('../locate/tag');
var tag = require('../util/html').tag;

module.exports = inlineHTML;
inlineHTML.locator = locate;

var EXPRESSION_HTML_LINK_OPEN = /^<a /i;
var EXPRESSION_HTML_LINK_CLOSE = /^<\/a>/i;

function inlineHTML(eat, value, silent) {
  var self = this;
  var length = value.length;
  var character;
  var subvalue;

  if (value.charAt(0) !== '<' || length < 3) {
    return;
  }

  character = value.charAt(1);

  if (
    !alphabetical(character) &&
    character !== '?' &&
    character !== '!' &&
    character !== '/'
  ) {
    return;
  }

  subvalue = value.match(tag);

  if (!subvalue) {
    return;
  }

  /* istanbul ignore if - not used yet. */
  if (silent) {
    return true;
  }

  subvalue = subvalue[0];

  if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {
    self.inLink = true;
  } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {
    self.inLink = false;
  }

  return eat(subvalue)({type: 'html', value: subvalue});
}

},{"../locate/tag":39,"../util/html":72,"is-alphabetical":12}],59:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var locate = require('../locate/link');

module.exports = link;
link.locator = locate;

var own = {}.hasOwnProperty;

var C_BACKSLASH = '\\';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';
var C_PAREN_OPEN = '(';
var C_PAREN_CLOSE = ')';
var C_LT = '<';
var C_GT = '>';
var C_TICK = '`';
var C_DOUBLE_QUOTE = '"';
var C_SINGLE_QUOTE = '\'';

/* Map of characters, which can be used to mark link
 * and image titles. */
var LINK_MARKERS = {};

LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;

/* Map of characters, which can be used to mark link
 * and image titles in commonmark-mode. */
var COMMONMARK_LINK_MARKERS = {};

COMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
COMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;
COMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;

function link(eat, value, silent) {
  var self = this;
  var subvalue = '';
  var index = 0;
  var character = value.charAt(0);
  var pedantic = self.options.pedantic;
  var commonmark = self.options.commonmark;
  var gfm = self.options.gfm;
  var closed;
  var count;
  var opening;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var markers;
  var isImage;
  var content;
  var marker;
  var length;
  var title;
  var depth;
  var queue;
  var url;
  var now;
  var exit;
  var node;

  /* Detect whether this is an image. */
  if (character === '!') {
    isImage = true;
    subvalue = character;
    character = value.charAt(++index);
  }

  /* Eat the opening. */
  if (character !== C_BRACKET_OPEN) {
    return;
  }

  /* Exit when this is a link and we‚Äôre already inside
   * a link. */
  if (!isImage && self.inLink) {
    return;
  }

  subvalue += character;
  queue = '';
  index++;

  /* Eat the content. */
  length = value.length;
  now = eat.now();
  depth = 0;

  now.column += index;
  now.offset += index;

  while (index < length) {
    character = value.charAt(index);
    subqueue = character;

    if (character === C_TICK) {
      /* Inline-code in link content. */
      count = 1;

      while (value.charAt(index + 1) === C_TICK) {
        subqueue += character;
        index++;
        count++;
      }

      if (!opening) {
        opening = count;
      } else if (count >= opening) {
        opening = 0;
      }
    } else if (character === C_BACKSLASH) {
      /* Allow brackets to be escaped. */
      index++;
      subqueue += value.charAt(index);
    /* In GFM mode, brackets in code still count.
     * In all other modes, they don‚Äôt.  This empty
     * block prevents the next statements are
     * entered. */
    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {
      depth++;
    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {
      if (depth) {
        depth--;
      } else {
        /* Allow white-space between content and
         * url in GFM mode. */
        if (!pedantic) {
          while (index < length) {
            character = value.charAt(index + 1);

            if (!whitespace(character)) {
              break;
            }

            subqueue += character;
            index++;
          }
        }

        if (value.charAt(index + 1) !== C_PAREN_OPEN) {
          return;
        }

        subqueue += C_PAREN_OPEN;
        closed = true;
        index++;

        break;
      }
    }

    queue += subqueue;
    subqueue = '';
    index++;
  }

  /* Eat the content closing. */
  if (!closed) {
    return;
  }

  content = queue;
  subvalue += queue + subqueue;
  index++;

  /* Eat white-space. */
  while (index < length) {
    character = value.charAt(index);

    if (!whitespace(character)) {
      break;
    }

    subvalue += character;
    index++;
  }

  /* Eat the URL. */
  character = value.charAt(index);
  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;
  queue = '';
  beforeURL = subvalue;

  if (character === C_LT) {
    index++;
    beforeURL += C_LT;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_GT) {
        break;
      }

      if (commonmark && character === '\n') {
        return;
      }

      queue += character;
      index++;
    }

    if (value.charAt(index) !== C_GT) {
      return;
    }

    subvalue += C_LT + queue + C_GT;
    url = queue;
    index++;
  } else {
    character = null;
    subqueue = '';

    while (index < length) {
      character = value.charAt(index);

      if (subqueue && own.call(markers, character)) {
        break;
      }

      if (whitespace(character)) {
        if (!pedantic) {
          break;
        }

        subqueue += character;
      } else {
        if (character === C_PAREN_OPEN) {
          depth++;
        } else if (character === C_PAREN_CLOSE) {
          if (depth === 0) {
            break;
          }

          depth--;
        }

        queue += subqueue;
        subqueue = '';

        if (character === C_BACKSLASH) {
          queue += C_BACKSLASH;
          character = value.charAt(++index);
        }

        queue += character;
      }

      index++;
    }

    subvalue += queue;
    url = queue;
    index = subvalue.length;
  }

  /* Eat white-space. */
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!whitespace(character)) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  subvalue += queue;

  /* Eat the title. */
  if (queue && own.call(markers, character)) {
    index++;
    subvalue += character;
    queue = '';
    marker = markers[character];
    beforeTitle = subvalue;

    /* In commonmark-mode, things are pretty easy: the
     * marker cannot occur inside the title.
     *
     * Non-commonmark does, however, support nested
     * delimiters. */
    if (commonmark) {
      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          break;
        }

        if (character === C_BACKSLASH) {
          queue += C_BACKSLASH;
          character = value.charAt(++index);
        }

        index++;
        queue += character;
      }

      character = value.charAt(index);

      if (character !== marker) {
        return;
      }

      title = queue;
      subvalue += queue + character;
      index++;

      while (index < length) {
        character = value.charAt(index);

        if (!whitespace(character)) {
          break;
        }

        subvalue += character;
        index++;
      }
    } else {
      subqueue = '';

      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          if (hasMarker) {
            queue += marker + subqueue;
            subqueue = '';
          }

          hasMarker = true;
        } else if (!hasMarker) {
          queue += character;
        } else if (character === C_PAREN_CLOSE) {
          subvalue += queue + marker + subqueue;
          title = queue;
          break;
        } else if (whitespace(character)) {
          subqueue += character;
        } else {
          queue += marker + subqueue + character;
          subqueue = '';
          hasMarker = false;
        }

        index++;
      }
    }
  }

  if (value.charAt(index) !== C_PAREN_CLOSE) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  subvalue += C_PAREN_CLOSE;

  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end);

  if (title) {
    beforeTitle = eat(beforeTitle).test().end;
    title = self.decode.raw(self.unescape(title), beforeTitle);
  }

  node = {
    type: isImage ? 'image' : 'link',
    title: title || null,
    url: url
  };

  if (isImage) {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  } else {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  }

  return eat(subvalue)(node);
}

},{"../locate/link":37,"is-whitespace-character":19}],60:[function(require,module,exports){
'use strict';

/* eslint-disable max-params */

var trim = require('trim');
var repeat = require('repeat-string');
var decimal = require('is-decimal');
var getIndent = require('../util/get-indentation');
var removeIndent = require('../util/remove-indentation');
var interrupt = require('../util/interrupt');

module.exports = list;

var C_ASTERISK = '*';
var C_UNDERSCORE = '_';
var C_PLUS = '+';
var C_DASH = '-';
var C_DOT = '.';
var C_SPACE = ' ';
var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_PAREN_CLOSE = ')';
var C_X_LOWER = 'x';

var TAB_SIZE = 4;
var EXPRESSION_LOOSE_LIST_ITEM = /\n\n(?!\s*$)/;
var EXPRESSION_TASK_ITEM = /^\[([ \t]|x|X)][ \t]/;
var EXPRESSION_BULLET = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var EXPRESSION_PEDANTIC_BULLET = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var EXPRESSION_INITIAL_INDENT = /^( {1,4}|\t)?/gm;

/* Map of characters which can be used to mark
 * list-items. */
var LIST_UNORDERED_MARKERS = {};

LIST_UNORDERED_MARKERS[C_ASTERISK] = true;
LIST_UNORDERED_MARKERS[C_PLUS] = true;
LIST_UNORDERED_MARKERS[C_DASH] = true;

/* Map of characters which can be used to mark
 * list-items after a digit. */
var LIST_ORDERED_MARKERS = {};

LIST_ORDERED_MARKERS[C_DOT] = true;

/* Map of characters which can be used to mark
 * list-items after a digit. */
var LIST_ORDERED_COMMONMARK_MARKERS = {};

LIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;
LIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;

function list(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var pedantic = self.options.pedantic;
  var tokenizers = self.blockTokenizers;
  var interuptors = self.interruptList;
  var markers;
  var index = 0;
  var length = value.length;
  var start = null;
  var size = 0;
  var queue;
  var ordered;
  var character;
  var marker;
  var nextIndex;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line;
  var prevEmpty;
  var empty;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var isLoose;
  var node;
  var now;
  var end;
  var indented;

  while (index < length) {
    character = value.charAt(index);

    if (character === C_TAB) {
      size += TAB_SIZE - (size % TAB_SIZE);
    } else if (character === C_SPACE) {
      size++;
    } else {
      break;
    }

    index++;
  }

  if (size >= TAB_SIZE) {
    return;
  }

  character = value.charAt(index);

  markers = commonmark ?
    LIST_ORDERED_COMMONMARK_MARKERS :
    LIST_ORDERED_MARKERS;

  if (LIST_UNORDERED_MARKERS[character] === true) {
    marker = character;
    ordered = false;
  } else {
    ordered = true;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (!decimal(character)) {
        break;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (!queue || markers[character] !== true) {
      return;
    }

    start = parseInt(queue, 10);
    marker = character;
  }

  character = value.charAt(++index);

  if (character !== C_SPACE && character !== C_TAB) {
    return;
  }

  if (silent) {
    return true;
  }

  index = 0;
  items = [];
  allLines = [];
  emptyLines = [];

  while (index < length) {
    nextIndex = value.indexOf(C_NEWLINE, index);
    startIndex = index;
    prefixed = false;
    indented = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    end = index + TAB_SIZE;
    size = 0;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_TAB) {
        size += TAB_SIZE - (size % TAB_SIZE);
      } else if (character === C_SPACE) {
        size++;
      } else {
        break;
      }

      index++;
    }

    if (size >= TAB_SIZE) {
      indented = true;
    }

    if (item && size >= item.indent) {
      indented = true;
    }

    character = value.charAt(index);
    currentMarker = null;

    if (!indented) {
      if (LIST_UNORDERED_MARKERS[character] === true) {
        currentMarker = character;
        index++;
        size++;
      } else {
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (!decimal(character)) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        index++;

        if (queue && markers[character] === true) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }

      if (currentMarker) {
        character = value.charAt(index);

        if (character === C_TAB) {
          size += TAB_SIZE - (size % TAB_SIZE);
          index++;
        } else if (character === C_SPACE) {
          end = index + TAB_SIZE;

          while (index < end) {
            if (value.charAt(index) !== C_SPACE) {
              break;
            }

            index++;
            size++;
          }

          if (index === end && value.charAt(index) === C_SPACE) {
            index -= TAB_SIZE - 1;
            size -= TAB_SIZE - 1;
          }
        } else if (character !== C_NEWLINE && character !== '') {
          currentMarker = null;
        }
      }
    }

    if (currentMarker) {
      if (!pedantic && marker !== currentMarker) {
        break;
      }

      prefixed = true;
    } else {
      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {
        indented = true;
      } else if (commonmark && item) {
        indented = size >= item.indent || size > TAB_SIZE;
      }

      prefixed = false;
      index = startIndex;
    }

    line = value.slice(startIndex, nextIndex);
    content = startIndex === index ? line : value.slice(index, nextIndex);

    if (
      currentMarker === C_ASTERISK ||
      currentMarker === C_UNDERSCORE ||
      currentMarker === C_DASH
    ) {
      if (tokenizers.thematicBreak.call(self, eat, line, true)) {
        break;
      }
    }

    prevEmpty = empty;
    empty = !trim(content).length;

    if (indented && item) {
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        item.value.push('');
        item.trail = emptyLines.concat();
      }

      item = {
        value: [line],
        indent: size,
        trail: []
      };

      items.push(item);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (empty) {
      if (prevEmpty) {
        break;
      }

      emptyLines.push(line);
    } else {
      if (prevEmpty) {
        break;
      }

      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {
        break;
      }

      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    }

    index = nextIndex + 1;
  }

  node = eat(allLines.join(C_NEWLINE)).reset({
    type: 'list',
    ordered: ordered,
    start: start,
    loose: null,
    children: []
  });

  enterTop = self.enterList();
  exitBlockquote = self.enterBlock();
  isLoose = false;
  index = -1;
  length = items.length;

  while (++index < length) {
    item = items[index].value.join(C_NEWLINE);
    now = eat.now();

    item = eat(item)(listItem(self, item, now), node);

    if (item.loose) {
      isLoose = true;
    }

    item = items[index].trail.join(C_NEWLINE);

    if (index !== length - 1) {
      item += C_NEWLINE;
    }

    eat(item);
  }

  enterTop();
  exitBlockquote();

  node.loose = isLoose;

  return node;
}

function listItem(ctx, value, position) {
  var offsets = ctx.offset;
  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
  var checked = null;
  var task;
  var indent;

  value = fn.apply(null, arguments);

  if (ctx.options.gfm) {
    task = value.match(EXPRESSION_TASK_ITEM);

    if (task) {
      indent = task[0].length;
      checked = task[1].toLowerCase() === C_X_LOWER;
      offsets[position.line] += indent;
      value = value.slice(indent);
    }
  }

  return {
    type: 'listItem',
    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||
      value.charAt(value.length - 1) === C_NEWLINE,
    checked: checked,
    children: ctx.tokenizeBlock(value, position)
  };
}

/* Create a list-item using overly simple mechanics. */
function pedanticListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;

  /* Remove the list-item‚Äôs bullet. */
  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);

  /* The initial line was also matched by the below, so
   * we reset the `line`. */
  line = position.line;

  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);

  /* A simple replacer which removed all matches,
   * and adds their length to `offset`. */
  function replacer($0) {
    offsets[line] = (offsets[line] || 0) + $0.length;
    line++;

    return '';
  }
}

/* Create a list-item using sane mechanics. */
function normalListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;
  var max;
  var bullet;
  var rest;
  var lines;
  var trimmedLines;
  var index;
  var length;

  /* Remove the list-item‚Äôs bullet. */
  value = value.replace(EXPRESSION_BULLET, replacer);

  lines = value.split(C_NEWLINE);

  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);

  /* We replaced the initial bullet with something
   * else above, which was used to trick
   * `removeIndentation` into removing some more
   * characters when possible.  However, that could
   * result in the initial line to be stripped more
   * than it should be. */
  trimmedLines[0] = rest;

  offsets[line] = (offsets[line] || 0) + bullet.length;
  line++;

  index = 0;
  length = lines.length;

  while (++index < length) {
    offsets[line] = (offsets[line] || 0) +
      lines[index].length - trimmedLines[index].length;
    line++;
  }

  return trimmedLines.join(C_NEWLINE);

  function replacer($0, $1, $2, $3, $4) {
    bullet = $1 + $2 + $3;
    rest = $4;

    /* Make sure that the first nine numbered list items
     * can indent with an extra space.  That is, when
     * the bullet did not receive an extra final space. */
    if (Number($2) < 10 && bullet.length % 2 === 1) {
      $2 = C_SPACE + $2;
    }

    max = $1 + repeat(C_SPACE, $2.length) + $3;

    return max + rest;
  }
}

},{"../util/get-indentation":71,"../util/interrupt":73,"../util/remove-indentation":75,"is-decimal":16,"repeat-string":121,"trim":128}],61:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');

module.exports = newline;

/* Tokenise newline. */
function newline(eat, value, silent) {
  var character = value.charAt(0);
  var length;
  var subvalue;
  var queue;
  var index;

  if (character !== '\n') {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  index = 1;
  length = value.length;
  subvalue = character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!whitespace(character)) {
      break;
    }

    queue += character;

    if (character === '\n') {
      subvalue += queue;
      queue = '';
    }

    index++;
  }

  eat(subvalue);
}

},{"is-whitespace-character":19}],62:[function(require,module,exports){
'use strict';

var trim = require('trim');
var decimal = require('is-decimal');
var trimTrailingLines = require('trim-trailing-lines');
var interrupt = require('../util/interrupt');

module.exports = paragraph;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';

var TAB_SIZE = 4;

/* Tokenise paragraph. */
function paragraph(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var commonmark = settings.commonmark;
  var gfm = settings.gfm;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptParagraph;
  var index = value.indexOf(C_NEWLINE);
  var length = value.length;
  var position;
  var subvalue;
  var character;
  var size;
  var now;

  while (index < length) {
    /* Eat everything if there‚Äôs no following newline. */
    if (index === -1) {
      index = length;
      break;
    }

    /* Stop if the next character is NEWLINE. */
    if (value.charAt(index + 1) === C_NEWLINE) {
      break;
    }

    /* In commonmark-mode, following indented lines
     * are part of the paragraph. */
    if (commonmark) {
      size = 0;
      position = index + 1;

      while (position < length) {
        character = value.charAt(position);

        if (character === C_TAB) {
          size = TAB_SIZE;
          break;
        } else if (character === C_SPACE) {
          size++;
        } else {
          break;
        }

        position++;
      }

      if (size >= TAB_SIZE) {
        index = value.indexOf(C_NEWLINE, index + 1);
        continue;
      }
    }

    subvalue = value.slice(index + 1);

    /* Check if the following code contains a possible
     * block. */
    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {
      break;
    }

    /* Break if the following line starts a list, when
     * already in a list, or when in commonmark, or when
     * in gfm mode and the bullet is *not* numeric. */
    if (
      tokenizers.list.call(self, eat, subvalue, true) &&
      (
        self.inList ||
        commonmark ||
        (gfm && !decimal(trim.left(subvalue).charAt(0)))
      )
    ) {
      break;
    }

    position = index;
    index = value.indexOf(C_NEWLINE, index + 1);

    if (index !== -1 && trim(value.slice(position, index)) === '') {
      index = position;
      break;
    }
  }

  subvalue = value.slice(0, index);

  if (trim(subvalue) === '') {
    eat(subvalue);

    return null;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  now = eat.now();
  subvalue = trimTrailingLines(subvalue);

  return eat(subvalue)({
    type: 'paragraph',
    children: self.tokenizeInline(subvalue, now)
  });
}

},{"../util/interrupt":73,"is-decimal":16,"trim":128,"trim-trailing-lines":127}],63:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');
var locate = require('../locate/link');
var normalize = require('../util/normalize');

module.exports = reference;
reference.locator = locate;

var T_LINK = 'link';
var T_IMAGE = 'image';
var T_FOOTNOTE = 'footnote';
var REFERENCE_TYPE_SHORTCUT = 'shortcut';
var REFERENCE_TYPE_COLLAPSED = 'collapsed';
var REFERENCE_TYPE_FULL = 'full';
var C_CARET = '^';
var C_BACKSLASH = '\\';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';

function reference(eat, value, silent) {
  var self = this;
  var character = value.charAt(0);
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var intro = '';
  var type = T_LINK;
  var referenceType = REFERENCE_TYPE_SHORTCUT;
  var content;
  var identifier;
  var now;
  var node;
  var exit;
  var queue;
  var bracketed;
  var depth;

  /* Check whether we‚Äôre eating an image. */
  if (character === '!') {
    type = T_IMAGE;
    intro = character;
    character = value.charAt(++index);
  }

  if (character !== C_BRACKET_OPEN) {
    return;
  }

  index++;
  intro += character;
  queue = '';

  /* Check whether we‚Äôre eating a footnote. */
  if (
    self.options.footnotes &&
    type === T_LINK &&
    value.charAt(index) === C_CARET
  ) {
    intro += C_CARET;
    index++;
    type = T_FOOTNOTE;
  }

  /* Eat the text. */
  depth = 0;

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_OPEN) {
      bracketed = true;
      depth++;
    } else if (character === C_BRACKET_CLOSE) {
      if (!depth) {
        break;
      }

      depth--;
    }

    if (character === C_BACKSLASH) {
      queue += C_BACKSLASH;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }

  subvalue = queue;
  content = queue;
  character = value.charAt(index);

  if (character !== C_BRACKET_CLOSE) {
    return;
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!whitespace(character)) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  /* Inline footnotes cannot have an identifier. */
  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {
    identifier = '';
    queue += character;
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {
        break;
      }

      if (character === C_BACKSLASH) {
        identifier += C_BACKSLASH;
        character = value.charAt(++index);
      }

      identifier += character;
      index++;
    }

    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE) {
      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;
      queue += identifier + character;
      index++;
    } else {
      identifier = '';
    }

    subvalue += queue;
    queue = '';
  } else {
    if (!content) {
      return;
    }

    identifier = content;
  }

  /* Brackets cannot be inside the identifier. */
  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {
    return;
  }

  subvalue = intro + subvalue;

  if (type === T_LINK && self.inLink) {
    return null;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {
    return eat(subvalue)({
      type: 'footnote',
      children: this.tokenizeInline(content, eat.now())
    });
  }

  now = eat.now();
  now.column += intro.length;
  now.offset += intro.length;
  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;

  node = {
    type: type + 'Reference',
    identifier: normalize(identifier)
  };

  if (type === T_LINK || type === T_IMAGE) {
    node.referenceType = referenceType;
  }

  if (type === T_LINK) {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  } else if (type === T_IMAGE) {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  }

  return eat(subvalue)(node);
}

},{"../locate/link":37,"../util/normalize":74,"is-whitespace-character":19}],64:[function(require,module,exports){
'use strict';

var trim = require('trim');
var whitespace = require('is-whitespace-character');
var locate = require('../locate/strong');

module.exports = strong;
strong.locator = locate;

var C_ASTERISK = '*';
var C_UNDERSCORE = '_';

function strong(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var prev;

  if (
    (character !== C_ASTERISK && character !== C_UNDERSCORE) ||
    value.charAt(++index) !== character
  ) {
    return;
  }

  pedantic = self.options.pedantic;
  marker = character;
  subvalue = marker + marker;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && whitespace(value.charAt(index))) {
    return;
  }

  while (index < length) {
    prev = character;
    character = value.charAt(index);

    if (
      character === marker &&
      value.charAt(index + 1) === marker &&
      (!pedantic || !whitespace(prev))
    ) {
      character = value.charAt(index + 2);

      if (character !== marker) {
        if (!trim(queue)) {
          return;
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true;
        }

        now = eat.now();
        now.column += 2;
        now.offset += 2;

        return eat(subvalue + queue + subvalue)({
          type: 'strong',
          children: self.tokenizeInline(queue, now)
        });
      }
    }

    if (!pedantic && character === '\\') {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

},{"../locate/strong":38,"is-whitespace-character":19,"trim":128}],65:[function(require,module,exports){
'use strict';

var whitespace = require('is-whitespace-character');

module.exports = table;

var C_BACKSLASH = '\\';
var C_TICK = '`';
var C_DASH = '-';
var C_PIPE = '|';
var C_COLON = ':';
var C_SPACE = ' ';
var C_NEWLINE = '\n';
var C_TAB = '\t';

var MIN_TABLE_COLUMNS = 1;
var MIN_TABLE_ROWS = 2;

var TABLE_ALIGN_LEFT = 'left';
var TABLE_ALIGN_CENTER = 'center';
var TABLE_ALIGN_RIGHT = 'right';
var TABLE_ALIGN_NONE = null;

function table(eat, value, silent) {
  var self = this;
  var index;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var count;
  var opening;
  var now;
  var position;
  var lineCount;
  var line;
  var rows;
  var table;
  var lineIndex;
  var pipeIndex;
  var first;

  /* Exit when not in gfm-mode. */
  if (!self.options.gfm) {
    return;
  }

  /* Get the rows.
   * Detecting tables soon is hard, so there are some
   * checks for performance here, such as the minimum
   * number of rows, and allowed characters in the
   * alignment row. */
  index = 0;
  lineCount = 0;
  length = value.length + 1;
  lines = [];

  while (index < length) {
    lineIndex = value.indexOf(C_NEWLINE, index);
    pipeIndex = value.indexOf(C_PIPE, index + 1);

    if (lineIndex === -1) {
      lineIndex = value.length;
    }

    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < MIN_TABLE_ROWS) {
        return;
      }

      break;
    }

    lines.push(value.slice(index, lineIndex));
    lineCount++;
    index = lineIndex + 1;
  }

  /* Parse the alignment row. */
  subvalue = lines.join(C_NEWLINE);
  alignments = lines.splice(1, 1)[0] || [];
  index = 0;
  length = alignments.length;
  lineCount--;
  alignment = false;
  align = [];

  while (index < length) {
    character = alignments.charAt(index);

    if (character === C_PIPE) {
      hasDash = null;

      if (alignment === false) {
        if (first === false) {
          return;
        }
      } else {
        align.push(alignment);
        alignment = false;
      }

      first = false;
    } else if (character === C_DASH) {
      hasDash = true;
      alignment = alignment || TABLE_ALIGN_NONE;
    } else if (character === C_COLON) {
      if (alignment === TABLE_ALIGN_LEFT) {
        alignment = TABLE_ALIGN_CENTER;
      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {
        alignment = TABLE_ALIGN_RIGHT;
      } else {
        alignment = TABLE_ALIGN_LEFT;
      }
    } else if (!whitespace(character)) {
      return;
    }

    index++;
  }

  if (alignment !== false) {
    align.push(alignment);
  }

  /* Exit when without enough columns. */
  if (align.length < MIN_TABLE_COLUMNS) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  /* Parse the rows. */
  position = -1;
  rows = [];

  table = eat(subvalue).reset({
    type: 'table',
    align: align,
    children: rows
  });

  while (++position < lineCount) {
    line = lines[position];
    row = {type: 'tableRow', children: []};

    /* Eat a newline character when this is not the
     * first row. */
    if (position) {
      eat(C_NEWLINE);
    }

    /* Eat the row. */
    eat(line).reset(row, table);

    length = line.length + 1;
    index = 0;
    queue = '';
    cell = '';
    preamble = true;
    count = null;
    opening = null;

    while (index < length) {
      character = line.charAt(index);

      if (character === C_TAB || character === C_SPACE) {
        if (cell) {
          queue += character;
        } else {
          eat(character);
        }

        index++;
        continue;
      }

      if (character === '' || character === C_PIPE) {
        if (preamble) {
          eat(character);
        } else {
          if (character && opening) {
            queue += character;
            index++;
            continue;
          }

          if ((cell || character) && !preamble) {
            subvalue = cell;

            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, queue.length - 1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = '';
              }
            }

            now = eat.now();

            eat(subvalue)({
              type: 'tableCell',
              children: self.tokenizeInline(cell, now)
            }, row);
          }

          eat(queue + character);

          queue = '';
          cell = '';
        }
      } else {
        if (queue) {
          cell += queue;
          queue = '';
        }

        cell += character;

        if (character === C_BACKSLASH && index !== length - 2) {
          cell += line.charAt(index + 1);
          index++;
        }

        if (character === C_TICK) {
          count = 1;

          while (line.charAt(index + 1) === character) {
            cell += character;
            index++;
            count++;
          }

          if (!opening) {
            opening = count;
          } else if (count >= opening) {
            opening = 0;
          }
        }
      }

      preamble = false;
      index++;
    }

    /* Eat the alignment row. */
    if (!position) {
      eat(C_NEWLINE + alignments);
    }
  }

  return table;
}

},{"is-whitespace-character":19}],66:[function(require,module,exports){
'use strict';

module.exports = text;

function text(eat, value, silent) {
  var self = this;
  var methods;
  var tokenizers;
  var index;
  var length;
  var subvalue;
  var position;
  var tokenizer;
  var name;
  var min;
  var now;

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  methods = self.inlineMethods;
  length = methods.length;
  tokenizers = self.inlineTokenizers;
  index = -1;
  min = value.length;

  while (++index < length) {
    name = methods[index];

    if (name === 'text' || !tokenizers[name]) {
      continue;
    }

    tokenizer = tokenizers[name].locator;

    if (!tokenizer) {
      eat.file.fail('Missing locator: `' + name + '`');
    }

    position = tokenizer.call(self, value, 1);

    if (position !== -1 && position < min) {
      min = position;
    }
  }

  subvalue = value.slice(0, min);
  now = eat.now();

  self.decode(subvalue, now, function (content, position, source) {
    eat(source || content)({
      type: 'text',
      value: content
    });
  });
}

},{}],67:[function(require,module,exports){
'use strict';

module.exports = thematicBreak;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';
var C_ASTERISK = '*';
var C_UNDERSCORE = '_';
var C_DASH = '-';

var THEMATIC_BREAK_MARKER_COUNT = 3;

function thematicBreak(eat, value, silent) {
  var index = -1;
  var length = value.length + 1;
  var subvalue = '';
  var character;
  var marker;
  var markerCount;
  var queue;

  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_TAB && character !== C_SPACE) {
      break;
    }

    subvalue += character;
  }

  if (
    character !== C_ASTERISK &&
    character !== C_DASH &&
    character !== C_UNDERSCORE
  ) {
    return;
  }

  marker = character;
  subvalue += character;
  markerCount = 1;
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === marker) {
      markerCount++;
      subvalue += queue + marker;
      queue = '';
    } else if (character === C_SPACE) {
      queue += character;
    } else if (
      markerCount >= THEMATIC_BREAK_MARKER_COUNT &&
      (!character || character === C_NEWLINE)
    ) {
      subvalue += queue;

      if (silent) {
        return true;
      }

      return eat(subvalue)({type: 'thematicBreak'});
    } else {
      return;
    }
  }
}

},{}],68:[function(require,module,exports){
'use strict';

var decode = require('parse-entities');
var whitespace = require('is-whitespace-character');
var locate = require('../locate/url');

module.exports = url;
url.locator = locate;
url.notInLink = true;

var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';
var C_PAREN_OPEN = '(';
var C_PAREN_CLOSE = ')';
var C_LT = '<';
var C_AT_SIGN = '@';

var HTTP_PROTOCOL = 'http://';
var HTTPS_PROTOCOL = 'https://';
var MAILTO_PROTOCOL = 'mailto:';

var PROTOCOLS = [
  HTTP_PROTOCOL,
  HTTPS_PROTOCOL,
  MAILTO_PROTOCOL
];

var PROTOCOLS_LENGTH = PROTOCOLS.length;

function url(eat, value, silent) {
  var self = this;
  var subvalue;
  var content;
  var character;
  var index;
  var position;
  var protocol;
  var match;
  var length;
  var queue;
  var parenCount;
  var nextCharacter;
  var exit;

  if (!self.options.gfm) {
    return;
  }

  subvalue = '';
  index = -1;
  length = PROTOCOLS_LENGTH;

  while (++index < length) {
    protocol = PROTOCOLS[index];
    match = value.slice(0, protocol.length);

    if (match.toLowerCase() === protocol) {
      subvalue = match;
      break;
    }
  }

  if (!subvalue) {
    return;
  }

  index = subvalue.length;
  length = value.length;
  queue = '';
  parenCount = 0;

  while (index < length) {
    character = value.charAt(index);

    if (whitespace(character) || character === C_LT) {
      break;
    }

    if (
      character === '.' ||
      character === ',' ||
      character === ':' ||
      character === ';' ||
      character === '"' ||
      character === '\'' ||
      character === ')' ||
      character === ']'
    ) {
      nextCharacter = value.charAt(index + 1);

      if (!nextCharacter || whitespace(nextCharacter)) {
        break;
      }
    }

    if (character === C_PAREN_OPEN || character === C_BRACKET_OPEN) {
      parenCount++;
    }

    if (character === C_PAREN_CLOSE || character === C_BRACKET_CLOSE) {
      parenCount--;

      if (parenCount < 0) {
        break;
      }
    }

    queue += character;
    index++;
  }

  if (!queue) {
    return;
  }

  subvalue += queue;
  content = subvalue;

  if (protocol === MAILTO_PROTOCOL) {
    position = queue.indexOf(C_AT_SIGN);

    if (position === -1 || position === length - 1) {
      return;
    }

    content = content.substr(MAILTO_PROTOCOL.length);
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  exit = self.enterLink();
  content = self.tokenizeInline(content, eat.now());
  exit();

  return eat(subvalue)({
    type: 'link',
    title: null,
    url: decode(subvalue),
    children: content
  });
}

},{"../locate/url":40,"is-whitespace-character":19,"parse-entities":25}],69:[function(require,module,exports){
'use strict';

module.exports = factory;

var MERGEABLE_NODES = {
  text: mergeText,
  blockquote: mergeBlockquote
};

/* Check whether a node is mergeable with adjacent nodes. */
function mergeable(node) {
  var start;
  var end;

  if (node.type !== 'text' || !node.position) {
    return true;
  }

  start = node.position.start;
  end = node.position.end;

  /* Only merge nodes which occupy the same size as their
   * `value`. */
  return start.line !== end.line ||
      end.column - start.column === node.value.length;
}

/* Merge two text nodes: `node` into `prev`. */
function mergeText(prev, node) {
  prev.value += node.value;

  return prev;
}

/* Merge two blockquotes: `node` into `prev`, unless in
 * CommonMark mode. */
function mergeBlockquote(prev, node) {
  if (this.options.commonmark) {
    return node;
  }

  prev.children = prev.children.concat(node.children);

  return prev;
}

/* Construct a tokenizer.  This creates both
 * `tokenizeInline` and `tokenizeBlock`. */
function factory(type) {
  return tokenize;

  /* Tokenizer for a bound `type`. */
  function tokenize(value, location) {
    var self = this;
    var offset = self.offset;
    var tokens = [];
    var methods = self[type + 'Methods'];
    var tokenizers = self[type + 'Tokenizers'];
    var line = location.line;
    var column = location.column;
    var index;
    var length;
    var method;
    var name;
    var matched;
    var valueLength;

    /* Trim white space only lines. */
    if (!value) {
      return tokens;
    }

    /* Expose on `eat`. */
    eat.now = now;
    eat.file = self.file;

    /* Sync initial offset. */
    updatePosition('');

    /* Iterate over `value`, and iterate over all
     * tokenizers.  When one eats something, re-iterate
     * with the remaining value.  If no tokenizer eats,
     * something failed (should not happen) and an
     * exception is thrown. */
    while (value) {
      index = -1;
      length = methods.length;
      matched = false;

      while (++index < length) {
        name = methods[index];
        method = tokenizers[name];

        if (
          method &&
          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&
          (!method.notInList || !self.inList) &&
          (!method.notInBlock || !self.inBlock) &&
          (!method.notInLink || !self.inLink)
        ) {
          valueLength = value.length;

          method.apply(self, [eat, value]);

          matched = valueLength !== value.length;

          if (matched) {
            break;
          }
        }
      }

      /* istanbul ignore if */
      if (!matched) {
        self.file.fail(new Error('Infinite loop'), eat.now());
      }
    }

    self.eof = now();

    return tokens;

    /* Update line, column, and offset based on
     * `value`. */
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index = subvalue.indexOf('\n');

      while (index !== -1) {
        line++;
        lastIndex = index;
        index = subvalue.indexOf('\n', index + 1);
      }

      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }

      if (line in offset) {
        if (lastIndex !== -1) {
          column += offset[line];
        } else if (column <= offset[line]) {
          column = offset[line] + 1;
        }
      }
    }

    /* Get offset.  Called before the first character is
     * eaten to retrieve the range's offsets. */
    function getOffset() {
      var indentation = [];
      var pos = line + 1;

      /* Done.  Called when the last character is
       * eaten to retrieve the range‚Äôs offsets. */
      return function () {
        var last = line + 1;

        while (pos < last) {
          indentation.push((offset[pos] || 0) + 1);

          pos++;
        }

        return indentation;
      };
    }

    /* Get the current position. */
    function now() {
      var pos = {line: line, column: column};

      pos.offset = self.toOffset(pos);

      return pos;
    }

    /* Store position information for a node. */
    function Position(start) {
      this.start = start;
      this.end = now();
    }

    /* Throw when a value is incorrectly eaten.
     * This shouldn‚Äôt happen but will throw on new,
     * incorrect rules. */
    function validateEat(subvalue) {
      /* istanbul ignore if */
      if (value.substring(0, subvalue.length) !== subvalue) {
        /* Capture stack-trace. */
        self.file.fail(
          new Error(
            'Incorrectly eaten value: please report this ' +
            'warning on http://git.io/vg5Ft'
          ),
          now()
        );
      }
    }

    /* Mark position and patch `node.position`. */
    function position() {
      var before = now();

      return update;

      /* Add the position to a node. */
      function update(node, indent) {
        var prev = node.position;
        var start = prev ? prev.start : before;
        var combined = [];
        var n = prev && prev.end.line;
        var l = before.line;

        node.position = new Position(start);

        /* If there was already a `position`, this
         * node was merged.  Fixing `start` wasn‚Äôt
         * hard, but the indent is different.
         * Especially because some information, the
         * indent between `n` and `l` wasn‚Äôt
         * tracked.  Luckily, that space is
         * (should be?) empty, so we can safely
         * check for it now. */
        if (prev && indent && prev.indent) {
          combined = prev.indent;

          if (n < l) {
            while (++n < l) {
              combined.push((offset[n] || 0) + 1);
            }

            combined.push(before.column);
          }

          indent = combined.concat(indent);
        }

        node.position.indent = indent || [];

        return node;
      }
    }

    /* Add `node` to `parent`s children or to `tokens`.
     * Performs merges where possible. */
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var prev = children[children.length - 1];

      if (
        prev &&
        node.type === prev.type &&
        node.type in MERGEABLE_NODES &&
        mergeable(prev) &&
        mergeable(node)
      ) {
        node = MERGEABLE_NODES[node.type].call(self, prev, node);
      }

      if (node !== prev) {
        children.push(node);
      }

      if (self.atStart && tokens.length !== 0) {
        self.exitStart();
      }

      return node;
    }

    /* Remove `subvalue` from `value`.
     * `subvalue` must be at the start of `value`. */
    function eat(subvalue) {
      var indent = getOffset();
      var pos = position();
      var current = now();

      validateEat(subvalue);

      apply.reset = reset;
      reset.test = test;
      apply.test = test;

      value = value.substring(subvalue.length);

      updatePosition(subvalue);

      indent = indent();

      return apply;

      /* Add the given arguments, add `position` to
       * the returned node, and return the node. */
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent);
      }

      /* Functions just like apply, but resets the
       * content:  the line and column are reversed,
       * and the eaten value is re-added.
       * This is useful for nodes with a single
       * type of content, such as lists and tables.
       * See `apply` above for what parameters are
       * expected. */
      function reset() {
        var node = apply.apply(null, arguments);

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return node;
      }

      /* Test the position, after eating, and reverse
       * to a not-eaten state. */
      function test() {
        var result = pos({});

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return result.position;
      }
    }
  }
}

},{}],70:[function(require,module,exports){
'use strict';

module.exports = factory;

/* Factory to de-escape a value, based on a list at `key`
 * in `ctx`. */
function factory(ctx, key) {
  return unescape;

  /* De-escape a string using the expression at `key`
   * in `ctx`. */
  function unescape(value) {
    var prev = 0;
    var index = value.indexOf('\\');
    var escape = ctx[key];
    var queue = [];
    var character;

    while (index !== -1) {
      queue.push(value.slice(prev, index));
      prev = index + 1;
      character = value.charAt(prev);

      /* If the following character is not a valid escape,
       * add the slash. */
      if (!character || escape.indexOf(character) === -1) {
        queue.push('\\');
      }

      index = value.indexOf('\\', prev);
    }

    queue.push(value.slice(prev));

    return queue.join('');
  }
}

},{}],71:[function(require,module,exports){
'use strict';

module.exports = indentation;

/* Map of characters, and their column length,
 * which can be used as indentation. */
var characters = {' ': 1, '\t': 4};

/* Gets indentation information for a line. */
function indentation(value) {
  var index = 0;
  var indent = 0;
  var character = value.charAt(index);
  var stops = {};
  var size;

  while (character in characters) {
    size = characters[character];

    indent += size;

    if (size > 1) {
      indent = Math.floor(indent / size) * size;
    }

    stops[indent] = index;

    character = value.charAt(++index);
  }

  return {indent: indent, stops: stops};
}

},{}],72:[function(require,module,exports){
'use strict';

var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
var singleQuoted = '\'[^\']*\'';
var doubleQuoted = '"[^"]*"';
var attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';
var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Za-z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

exports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');

exports.tag = new RegExp('^(?:' +
  openTag + '|' +
  closeTag + '|' +
  comment + '|' +
  processing + '|' +
  declaration + '|' +
  cdata +
')');

},{}],73:[function(require,module,exports){
'use strict';

module.exports = interrupt;

function interrupt(interruptors, tokenizers, ctx, params) {
  var bools = ['pedantic', 'commonmark'];
  var count = bools.length;
  var length = interruptors.length;
  var index = -1;
  var interruptor;
  var config;
  var fn;
  var offset;
  var bool;
  var ignore;

  while (++index < length) {
    interruptor = interruptors[index];
    config = interruptor[1] || {};
    fn = interruptor[0];
    offset = -1;
    ignore = false;

    while (++offset < count) {
      bool = bools[offset];

      if (config[bool] !== undefined && config[bool] !== ctx.options[bool]) {
        ignore = true;
        break;
      }
    }

    if (ignore) {
      continue;
    }

    if (tokenizers[fn].apply(ctx, params)) {
      return true;
    }
  }

  return false;
}

},{}],74:[function(require,module,exports){
'use strict';

var collapseWhiteSpace = require('collapse-white-space');

module.exports = normalize;

/* Normalize an identifier.  Collapses multiple white space
 * characters into a single space, and removes casing. */
function normalize(value) {
  return collapseWhiteSpace(value).toLowerCase();
}

},{"collapse-white-space":9}],75:[function(require,module,exports){
'use strict';

var trim = require('trim');
var repeat = require('repeat-string');
var getIndent = require('./get-indentation');

module.exports = indentation;

var C_SPACE = ' ';
var C_NEWLINE = '\n';
var C_TAB = '\t';

/* Remove the minimum indent from every line in `value`.
 * Supports both tab, spaced, and mixed indentation (as
 * well as possible). */
function indentation(value, maximum) {
  var values = value.split(C_NEWLINE);
  var position = values.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index;
  var indentation;
  var stops;
  var padding;

  values.unshift(repeat(C_SPACE, maximum) + '!');

  while (position--) {
    indentation = getIndent(values[position]);

    matrix[position] = indentation.stops;

    if (trim(values[position]).length === 0) {
      continue;
    }

    if (indentation.indent) {
      if (indentation.indent > 0 && indentation.indent < minIndent) {
        minIndent = indentation.indent;
      }
    } else {
      minIndent = Infinity;

      break;
    }
  }

  if (minIndent !== Infinity) {
    position = values.length;

    while (position--) {
      stops = matrix[position];
      index = minIndent;

      while (index && !(index in stops)) {
        index--;
      }

      if (
        trim(values[position]).length !== 0 &&
        minIndent &&
        index !== minIndent
      ) {
        padding = C_TAB;
      } else {
        padding = '';
      }

      values[position] = padding + values[position].slice(
        index in stops ? stops[index] + 1 : 0
      );
    }
  }

  values.shift();

  return values.join(C_NEWLINE);
}

},{"./get-indentation":71,"repeat-string":121,"trim":128}],76:[function(require,module,exports){
'use strict';

var unherit = require('unherit');
var xtend = require('xtend');
var Compiler = require('./lib/compiler.js');

module.exports = stringify;
stringify.Compiler = Compiler;

function stringify(options) {
  var Local = unherit(Compiler);
  Local.prototype.options = xtend(Local.prototype.options, this.data('settings'), options);
  this.Compiler = Local;
}

},{"./lib/compiler.js":77,"unherit":130,"xtend":140}],77:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var toggle = require('state-toggle');

module.exports = Compiler;

/* Construct a new compiler. */
function Compiler(tree, file) {
  this.inLink = false;
  this.inTable = false;
  this.tree = tree;
  this.file = file;
  this.options = xtend(this.options);
  this.setOptions({});
}

var proto = Compiler.prototype;

/* Enter and exit helpers. */
proto.enterLink = toggle('inLink', false);
proto.enterTable = toggle('inTable', false);
proto.enterLinkReference = require('./util/enter-link-reference');

/* Configuration. */
proto.options = require('./defaults');
proto.setOptions = require('./set-options');

proto.compile = require('./macro/compile');
proto.visit = require('./macro/one');
proto.all = require('./macro/all');
proto.block = require('./macro/block');
proto.visitOrderedItems = require('./macro/ordered-items');
proto.visitUnorderedItems = require('./macro/unordered-items');

/* Expose visitors. */
proto.visitors = {
  root: require('./visitors/root'),
  text: require('./visitors/text'),
  heading: require('./visitors/heading'),
  paragraph: require('./visitors/paragraph'),
  blockquote: require('./visitors/blockquote'),
  list: require('./visitors/list'),
  listItem: require('./visitors/list-item'),
  inlineCode: require('./visitors/inline-code'),
  code: require('./visitors/code'),
  html: require('./visitors/html'),
  thematicBreak: require('./visitors/thematic-break'),
  strong: require('./visitors/strong'),
  emphasis: require('./visitors/emphasis'),
  break: require('./visitors/break'),
  delete: require('./visitors/delete'),
  link: require('./visitors/link'),
  linkReference: require('./visitors/link-reference'),
  imageReference: require('./visitors/image-reference'),
  definition: require('./visitors/definition'),
  image: require('./visitors/image'),
  footnote: require('./visitors/footnote'),
  footnoteReference: require('./visitors/footnote-reference'),
  footnoteDefinition: require('./visitors/footnote-definition'),
  table: require('./visitors/table'),
  tableCell: require('./visitors/table-cell')
};

},{"./defaults":78,"./macro/all":80,"./macro/block":81,"./macro/compile":82,"./macro/one":83,"./macro/ordered-items":84,"./macro/unordered-items":85,"./set-options":86,"./util/enter-link-reference":90,"./visitors/blockquote":95,"./visitors/break":96,"./visitors/code":97,"./visitors/definition":98,"./visitors/delete":99,"./visitors/emphasis":100,"./visitors/footnote":103,"./visitors/footnote-definition":101,"./visitors/footnote-reference":102,"./visitors/heading":104,"./visitors/html":105,"./visitors/image":107,"./visitors/image-reference":106,"./visitors/inline-code":108,"./visitors/link":110,"./visitors/link-reference":109,"./visitors/list":112,"./visitors/list-item":111,"./visitors/paragraph":113,"./visitors/root":114,"./visitors/strong":115,"./visitors/table":117,"./visitors/table-cell":116,"./visitors/text":118,"./visitors/thematic-break":119,"state-toggle":123,"xtend":140}],78:[function(require,module,exports){
'use strict';

module.exports = {
  gfm: true,
  commonmark: false,
  pedantic: false,
  entities: 'false',
  setext: false,
  closeAtx: false,
  looseTable: false,
  spacedTable: true,
  paddedTable: true,
  stringLength: stringLength,
  incrementListMarker: true,
  fences: false,
  fence: '`',
  bullet: '-',
  listItemIndent: 'tab',
  rule: '*',
  ruleSpaces: true,
  ruleRepetition: 3,
  strong: '*',
  emphasis: '_'
};

function stringLength(value) {
  return value.length;
}

},{}],79:[function(require,module,exports){
'use strict';

var decimal = require('is-decimal');
var alphanumeric = require('is-alphanumeric');
var whitespace = require('is-whitespace-character');
var escapes = require('markdown-escapes');
var prefix = require('./util/entity-prefix-length');

module.exports = factory;

var BACKSLASH = '\\';
var BULLETS = ['*', '-', '+'];
var ALLIGNMENT = [':', '-', ' ', '|'];
var entities = {'<': '&lt;', ':': '&#x3A;', '&': '&amp;', '|': '&#x7C;', '~': '&#x7E;'};

/* Factory to escape characters. */
function factory(options) {
  return escape;

  /* Escape punctuation characters in a node's value. */
  function escape(value, node, parent) {
    var self = this;
    var gfm = options.gfm;
    var commonmark = options.commonmark;
    var pedantic = options.pedantic;
    var markers = commonmark ? ['.', ')'] : ['.'];
    var siblings = parent && parent.children;
    var index = siblings && siblings.indexOf(node);
    var prev = siblings && siblings[index - 1];
    var next = siblings && siblings[index + 1];
    var length = value.length;
    var escapable = escapes(options);
    var position = -1;
    var queue = [];
    var escaped = queue;
    var afterNewLine;
    var character;
    var wordCharBefore;
    var wordCharAfter;
    var offset;
    var replace;

    if (prev) {
      afterNewLine = text(prev) && /\n\s*$/.test(prev.value);
    } else {
      afterNewLine = !parent || parent.type === 'root' || parent.type === 'paragraph';
    }

    function one(character) {
      return escapable.indexOf(character) === -1 ?
        entities[character] : BACKSLASH + character;
    }

    while (++position < length) {
      character = value.charAt(position);
      replace = false;

      if (character === '\n') {
        afterNewLine = true;
      } else if (
        character === BACKSLASH ||
        character === '`' ||
        character === '*' ||
        character === '[' ||
        character === '<' ||
        (character === '&' && prefix(value.slice(position)) > 0) ||
        (character === ']' && self.inLink) ||
        (gfm && character === '~' && value.charAt(position + 1) === '~') ||
        (gfm && character === '|' && (self.inTable || alignment(value, position))) ||
        (
          character === '_' &&
          /* Delegate leading/trailing underscores
           * to the multinode version below. */
          position > 0 &&
          position < length - 1 &&
          (
              pedantic ||
              !alphanumeric(value.charAt(position - 1)) ||
              !alphanumeric(value.charAt(position + 1))
          )
        ) ||
        (gfm && !self.inLink && character === ':' && protocol(queue.join('')))
      ) {
        replace = true;
      } else if (afterNewLine) {
        if (
          character === '>' ||
          character === '#' ||
          BULLETS.indexOf(character) !== -1
        ) {
          replace = true;
        } else if (decimal(character)) {
          offset = position + 1;

          while (offset < length) {
            if (!decimal(value.charAt(offset))) {
              break;
            }

            offset++;
          }

          if (markers.indexOf(value.charAt(offset)) !== -1) {
            next = value.charAt(offset + 1);

            if (!next || next === ' ' || next === '\t' || next === '\n') {
              queue.push(value.slice(position, offset));
              position = offset;
              character = value.charAt(position);
              replace = true;
            }
          }
        }
      }

      if (afterNewLine && !whitespace(character)) {
        afterNewLine = false;
      }

      queue.push(replace ? one(character) : character);
    }

    /* Multi-node versions. */
    if (siblings && text(node)) {
      /* Check for an opening parentheses after a
       * link-reference (which can be joined by
       * white-space). */
      if (prev && prev.referenceType === 'shortcut') {
        position = -1;
        length = escaped.length;

        while (++position < length) {
          character = escaped[position];

          if (character === ' ' || character === '\t') {
            continue;
          }

          if (character === '(' || character === ':') {
            escaped[position] = one(character);
          }

          break;
        }

        /* If the current node is all spaces / tabs,
         * preceded by a shortcut, and followed by
         * a text starting with `(`, escape it. */
        if (
          text(next) &&
          position === length &&
          next.value.charAt(0) === '('
        ) {
          escaped.push(BACKSLASH);
        }
      }

      /* Ensure non-auto-links are not seen as links.
       * This pattern needs to check the preceding
       * nodes too. */
      if (
        gfm &&
        !self.inLink &&
        text(prev) &&
        value.charAt(0) === ':' &&
        protocol(prev.value.slice(-6))
      ) {
        escaped[0] = one(':');
      }

      /* Escape ampersand if it would otherwise
       * start an entity. */
      if (
        text(next) &&
        value.charAt(length - 1) === '&' &&
        prefix('&' + next.value) !== 0
      ) {
        escaped[escaped.length - 1] = one('&');
      }

      /* Escape double tildes in GFM. */
      if (
        gfm &&
        text(next) &&
        value.charAt(length - 1) === '~' &&
        next.value.charAt(0) === '~'
      ) {
        escaped.splice(escaped.length - 1, 0, BACKSLASH);
      }

      /* Escape underscores, but not mid-word (unless
       * in pedantic mode). */
      wordCharBefore = text(prev) && alphanumeric(prev.value.slice(-1));
      wordCharAfter = text(next) && alphanumeric(next.value.charAt(0));

      if (length === 1) {
        if (value === '_' && (pedantic || !wordCharBefore || !wordCharAfter)) {
          escaped.unshift(BACKSLASH);
        }
      } else {
        if (
          value.charAt(0) === '_' &&
          (pedantic || !wordCharBefore || !alphanumeric(value.charAt(1)))
        ) {
          escaped.unshift(BACKSLASH);
        }

        if (
          value.charAt(length - 1) === '_' &&
          (pedantic || !wordCharAfter || !alphanumeric(value.charAt(length - 2)))
        ) {
          escaped.splice(escaped.length - 1, 0, BACKSLASH);
        }
      }
    }

    return escaped.join('');
  }
}

/* Check if `index` in `value` is inside an alignment row. */
function alignment(value, index) {
  var start = value.lastIndexOf('\n', index);
  var end = value.indexOf('\n', index);

  start = start === -1 ? -1 : start;
  end = end === -1 ? value.length : end;

  while (++start < end) {
    if (ALLIGNMENT.indexOf(value.charAt(start)) === -1) {
      return false;
    }
  }

  return true;
}

/* Check if `node` is a text node. */
function text(node) {
  return node && node.type === 'text';
}

/* Check if `value` ends in a protocol. */
function protocol(value) {
  var val = value.slice(-6).toLowerCase();
  return val === 'mailto' || val.slice(-5) === 'https' || val.slice(-4) === 'http';
}

},{"./util/entity-prefix-length":91,"is-alphanumeric":13,"is-decimal":16,"is-whitespace-character":19,"markdown-escapes":22}],80:[function(require,module,exports){
'use strict';

module.exports = all;

/* Visit all children of `parent`. */
function all(parent) {
  var self = this;
  var children = parent.children;
  var length = children.length;
  var results = [];
  var index = -1;

  while (++index < length) {
    results[index] = self.visit(children[index], parent);
  }

  return results;
}

},{}],81:[function(require,module,exports){
'use strict';

module.exports = block;

/* Stringify a block node with block children (e.g., `root`
 * or `blockquote`).
 * Knows about code following a list, or adjacent lists
 * with similar bullets, and places an extra newline
 * between them. */
function block(node) {
  var self = this;
  var values = [];
  var children = node.children;
  var length = children.length;
  var index = -1;
  var child;
  var prev;

  while (++index < length) {
    child = children[index];

    if (prev) {
      /* Duplicate nodes, such as a list
       * directly following another list,
       * often need multiple new lines.
       *
       * Additionally, code blocks following a list
       * might easily be mistaken for a paragraph
       * in the list itself. */
      if (child.type === prev.type && prev.type === 'list') {
        values.push(prev.ordered === child.ordered ? '\n\n\n' : '\n\n');
      } else if (prev.type === 'list' && child.type === 'code' && !child.lang) {
        values.push('\n\n\n');
      } else {
        values.push('\n\n');
      }
    }

    values.push(self.visit(child, node));

    prev = child;
  }

  return values.join('');
}

},{}],82:[function(require,module,exports){
'use strict';

var compact = require('mdast-util-compact');

module.exports = compile;

/* Stringify the given tree. */
function compile() {
  return this.visit(compact(this.tree, this.options.commonmark));
}

},{"mdast-util-compact":24}],83:[function(require,module,exports){
'use strict';

module.exports = one;

function one(node, parent) {
  var self = this;
  var visitors = self.visitors;

  /* Fail on unknown nodes. */
  if (typeof visitors[node.type] !== 'function') {
    self.file.fail(
      new Error(
        'Missing compiler for node of type `' +
        node.type + '`: `' + node + '`'
      ),
      node
    );
  }

  return visitors[node.type].call(self, node, parent);
}

},{}],84:[function(require,module,exports){
'use strict';

module.exports = orderedItems;

/* Visit ordered list items.
 *
 * Starts the list with
 * `node.start` and increments each following list item
 * bullet by one:
 *
 *     2. foo
 *     3. bar
 *
 * In `incrementListMarker: false` mode, does not increment
 * each marker and stays on `node.start`:
 *
 *     1. foo
 *     1. bar
 */
function orderedItems(node) {
  var self = this;
  var fn = self.visitors.listItem;
  var increment = self.options.incrementListMarker;
  var values = [];
  var start = node.start;
  var children = node.children;
  var length = children.length;
  var index = -1;
  var bullet;

  while (++index < length) {
    bullet = (increment ? start + index : start) + '.';
    values[index] = fn.call(self, children[index], node, index, bullet);
  }

  return values.join('\n');
}

},{}],85:[function(require,module,exports){
'use strict';

module.exports = unorderedItems;

/* Visit unordered list items.
 * Uses `options.bullet` as each item's bullet.
 */
function unorderedItems(node) {
  var self = this;
  var bullet = self.options.bullet;
  var fn = self.visitors.listItem;
  var children = node.children;
  var length = children.length;
  var index = -1;
  var values = [];

  while (++index < length) {
    values[index] = fn.call(self, children[index], node, index, bullet);
  }

  return values.join('\n');
}

},{}],86:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var encode = require('stringify-entities');
var defaults = require('./defaults');
var escapeFactory = require('./escape');
var returner = require('./util/returner');

module.exports = setOptions;

/* Map of applicable enum's. */
var maps = {
  entities: {true: true, false: true, numbers: true, escape: true},
  bullet: {'*': true, '-': true, '+': true},
  rule: {'-': true, _: true, '*': true},
  listItemIndent: {tab: true, mixed: true, 1: true},
  emphasis: {_: true, '*': true},
  strong: {_: true, '*': true},
  fence: {'`': true, '~': true}
};

/* Expose `validate`. */
var validate = {
  boolean: validateBoolean,
  string: validateString,
  number: validateNumber,
  function: validateFunction
};

/* Set options.  Does not overwrite previously set
 * options. */
function setOptions(options) {
  var self = this;
  var current = self.options;
  var ruleRepetition;
  var key;

  if (options == null) {
    options = {};
  } else if (typeof options === 'object') {
    options = xtend(options);
  } else {
    throw new Error('Invalid value `' + options + '` for setting `options`');
  }

  for (key in defaults) {
    validate[typeof defaults[key]](options, key, current[key], maps[key]);
  }

  ruleRepetition = options.ruleRepetition;

  if (ruleRepetition && ruleRepetition < 3) {
    raise(ruleRepetition, 'options.ruleRepetition');
  }

  self.encode = encodeFactory(String(options.entities));
  self.escape = escapeFactory(options);

  self.options = options;

  return self;
}

/* Throw an exception with in its `message` `value`
 * and `name`. */
function raise(value, name) {
  throw new Error('Invalid value `' + value + '` for setting `' + name + '`');
}

/* Validate a value to be boolean. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * a boolean. */
function validateBoolean(context, name, def) {
  var value = context[name];

  if (value == null) {
    value = def;
  }

  if (typeof value !== 'boolean') {
    raise(value, 'options.' + name);
  }

  context[name] = value;
}

/* Validate a value to be boolean. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * a boolean. */
function validateNumber(context, name, def) {
  var value = context[name];

  if (value == null) {
    value = def;
  }

  if (isNaN(value)) {
    raise(value, 'options.' + name);
  }

  context[name] = value;
}

/* Validate a value to be in `map`. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * in `map`. */
function validateString(context, name, def, map) {
  var value = context[name];

  if (value == null) {
    value = def;
  }

  value = String(value);

  if (!(value in map)) {
    raise(value, 'options.' + name);
  }

  context[name] = value;
}

/* Validate a value to be function. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * a function. */
function validateFunction(context, name, def) {
  var value = context[name];

  if (value == null) {
    value = def;
  }

  if (typeof value !== 'function') {
    raise(value, 'options.' + name);
  }

  context[name] = value;
}

/* Factory to encode HTML entities.
 * Creates a no-operation function when `type` is
 * `'false'`, a function which encodes using named
 * references when `type` is `'true'`, and a function
 * which encodes using numbered references when `type` is
 * `'numbers'`. */
function encodeFactory(type) {
  var options = {};

  if (type === 'false') {
    return returner;
  }

  if (type === 'true') {
    options.useNamedReferences = true;
  }

  if (type === 'escape') {
    options.escapeOnly = true;
    options.useNamedReferences = true;
  }

  return wrapped;

  /* Encode HTML entities using the bound options. */
  function wrapped(value) {
    return encode(value, options);
  }
}

},{"./defaults":78,"./escape":79,"./util/returner":94,"stringify-entities":125,"xtend":140}],87:[function(require,module,exports){
'use strict';

var entityPrefixLength = require('./entity-prefix-length');

module.exports = copy;

var PUNCTUATION = /[-!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~_]/;

/* For shortcut and collapsed reference links, the contents
 * is also an identifier, so we need to restore the original
 * encoding and escaping that were present in the source
 * string.
 *
 * This function takes the unescaped & unencoded value from
 * shortcut's child nodes and the identifier and encodes
 * the former according to the latter. */
function copy(value, identifier) {
  var length = value.length;
  var count = identifier.length;
  var result = [];
  var position = 0;
  var index = 0;
  var start;

  while (index < length) {
    /* Take next non-punctuation characters from `value`. */
    start = index;

    while (index < length && !PUNCTUATION.test(value.charAt(index))) {
      index += 1;
    }

    result.push(value.slice(start, index));

    /* Advance `position` to the next punctuation character. */
    while (position < count && !PUNCTUATION.test(identifier.charAt(position))) {
      position += 1;
    }

    /* Take next punctuation characters from `identifier`. */
    start = position;

    while (position < count && PUNCTUATION.test(identifier.charAt(position))) {
      if (identifier.charAt(position) === '&') {
        position += entityPrefixLength(identifier.slice(position));
      }

      position += 1;
    }

    result.push(identifier.slice(start, position));

    /* Advance `index` to the next non-punctuation character. */
    while (index < length && PUNCTUATION.test(value.charAt(index))) {
      index += 1;
    }
  }

  return result.join('');
}

},{"./entity-prefix-length":91}],88:[function(require,module,exports){
'use strict';

module.exports = enclose;

/* There is currently no way to support nested delimiters
 * across Markdown.pl, CommonMark, and GitHub (RedCarpet).
 * The following code supports Markdown.pl and GitHub.
 * CommonMark is not supported when mixing double- and
 * single quotes inside a title. */
function enclose(title) {
  var delimiter = title.indexOf('"') === -1 ? '"' : '\'';
  return delimiter + title + delimiter;
}

},{}],89:[function(require,module,exports){
'use strict';

var count = require('ccount');

module.exports = enclose;

var re = /\s/;

/* Wrap `url` in angle brackets when needed, or when
 * forced.
 * In links, images, and definitions, the URL part needs
 * to be enclosed when it:
 *
 * - has a length of `0`;
 * - contains white-space;
 * - has more or less opening than closing parentheses.
 */
function enclose(uri, always) {
  if (always || uri.length === 0 || re.test(uri) || count(uri, '(') !== count(uri, ')')) {
    return '<' + uri + '>';
  }

  return uri;
}

},{"ccount":4}],90:[function(require,module,exports){
'use strict';

var returner = require('./returner');

module.exports = enter;

/* Shortcut and collapsed link references need no escaping
 * and encoding during the processing of child nodes (it
 * must be implied from identifier).
 *
 * This toggler turns encoding and escaping off for shortcut
 * and collapsed references.
 *
 * Implies `enterLink`.
 */
function enter(compiler, node) {
  var encode = compiler.encode;
  var escape = compiler.escape;
  var exit = compiler.enterLink();

  if (
    node.referenceType !== 'shortcut' &&
    node.referenceType !== 'collapsed'
  ) {
    return exit;
  }

  compiler.escape = returner;
  compiler.encode = returner;

  return function () {
    compiler.encode = encode;
    compiler.escape = escape;
    exit();
  };
}

},{"./returner":94}],91:[function(require,module,exports){
'use strict';

var decode = require('parse-entities');

module.exports = length;

/* Returns the length of HTML entity that is a prefix of
 * the given string (excluding the ampersand), 0 if it
 * does not start with an entity. */
function length(value) {
  var prefix;

  /* istanbul ignore if - Currently also tested for at
   * implemention, but we keep it here because that‚Äôs
   * proper. */
  if (value.charAt(0) !== '&') {
    return 0;
  }

  prefix = value.split('&', 2).join('&');

  return prefix.length - decode(prefix).length;
}

},{"parse-entities":25}],92:[function(require,module,exports){
'use strict';

module.exports = label;

/* Stringify a reference label.
 * Because link references are easily, mistakingly,
 * created (for example, `[foo]`), reference nodes have
 * an extra property depicting how it looked in the
 * original document, so stringification can cause minimal
 * changes. */
function label(node) {
  var type = node.referenceType;
  var value = type === 'full' ? node.identifier : '';

  return type === 'shortcut' ? value : '[' + value + ']';
}

},{}],93:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');

module.exports = pad;

var INDENT = 4;

/* Pad `value` with `level * INDENT` spaces.  Respects
 * lines. Ignores empty lines. */
function pad(value, level) {
  var index;
  var padding;

  value = value.split('\n');

  index = value.length;
  padding = repeat(' ', level * INDENT);

  while (index--) {
    if (value[index].length !== 0) {
      value[index] = padding + value[index];
    }
  }

  return value.join('\n');
}

},{"repeat-string":121}],94:[function(require,module,exports){
'use strict';

module.exports = returner;

function returner(value) {
  return value;
}

},{}],95:[function(require,module,exports){
'use strict';

module.exports = blockquote;

function blockquote(node) {
  var values = this.block(node).split('\n');
  var result = [];
  var length = values.length;
  var index = -1;
  var value;

  while (++index < length) {
    value = values[index];
    result[index] = (value ? ' ' : '') + value;
  }

  return '>' + result.join('\n>');
}

},{}],96:[function(require,module,exports){
'use strict';

module.exports = lineBreak;

var map = {true: '\\\n', false: '  \n'};

function lineBreak() {
  return map[this.options.commonmark];
}

},{}],97:[function(require,module,exports){
'use strict';

var streak = require('longest-streak');
var repeat = require('repeat-string');
var pad = require('../util/pad');

module.exports = code;

var FENCE = /([`~])\1{2}/;

/* Stringify code.
 * Creates indented code when:
 *
 * - No language tag exists;
 * - Not in `fences: true` mode;
 * - A non-empty value exists.
 *
 * Otherwise, GFM fenced code is created:
 *
 *     ```js
 *     foo();
 *     ```
 *
 * When in ``fence: `~` `` mode, uses tildes as fences:
 *
 *     ~~~js
 *     foo();
 *     ~~~
 *
 * Knows about internal fences (Note: GitHub/Kramdown does
 * not support this):
 *
 *     ````javascript
 *     ```markdown
 *     foo
 *     ```
 *     ````
 */
function code(node, parent) {
  var self = this;
  var value = node.value;
  var options = self.options;
  var marker = options.fence;
  var language = self.encode(node.lang || '', node);
  var fence;

  /* Without (needed) fences. */
  if (!language && !options.fences && value) {
    /* Throw when pedantic, in a list item which
     * isn‚Äôt compiled using a tab. */
    if (
      parent &&
      parent.type === 'listItem' &&
      options.listItemIndent !== 'tab' &&
      options.pedantic
    ) {
      self.file.fail('Cannot indent code properly. See http://git.io/vgFvT', node.position);
    }

    return pad(value, 1);
  }

  fence = streak(value, marker) + 1;

  /* Fix GFM / RedCarpet bug, where fence-like characters
   * inside fenced code can exit a code-block.
   * Yes, even when the outer fence uses different
   * characters, or is longer.
   * Thus, we can only pad the code to make it work. */
  if (FENCE.test(value)) {
    value = pad(value, 1);
  }

  fence = repeat(marker, Math.max(fence, 3));

  return fence + language + '\n' + value + '\n' + fence;
}

},{"../util/pad":93,"longest-streak":21,"repeat-string":121}],98:[function(require,module,exports){
'use strict';

var uri = require('../util/enclose-uri');
var title = require('../util/enclose-title');

module.exports = definition;

/* Stringify an URL definition.
 *
 * Is smart about enclosing `url` (see `encloseURI()`) and
 * `title` (see `encloseTitle()`).
 *
 *    [foo]: <foo at bar dot com> 'An "example" e-mail'
 */
function definition(node) {
  var content = uri(node.url);

  if (node.title) {
    content += ' ' + title(node.title);
  }

  return '[' + node.identifier + ']: ' + content;
}

},{"../util/enclose-title":88,"../util/enclose-uri":89}],99:[function(require,module,exports){
'use strict';

module.exports = strikethrough;

function strikethrough(node) {
  return '~~' + this.all(node).join('') + '~~';
}

},{}],100:[function(require,module,exports){
'use strict';

module.exports = emphasis;

/* Stringify an `emphasis`.
 *
 * The marker used is configurable through `emphasis`, which
 * defaults to an underscore (`'_'`) but also accepts an
 * asterisk (`'*'`):
 *
 *     *foo*
 */
function emphasis(node) {
  var marker = this.options.emphasis;
  return marker + this.all(node).join('') + marker;
}

},{}],101:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');

module.exports = footnoteDefinition;

function footnoteDefinition(node) {
  var id = node.identifier.toLowerCase();
  var content = this.all(node).join('\n\n' + repeat(' ', 4));

  return '[^' + id + ']: ' + content;
}

},{"repeat-string":121}],102:[function(require,module,exports){
'use strict';

module.exports = footnoteReference;

function footnoteReference(node) {
  return '[^' + node.identifier + ']';
}

},{}],103:[function(require,module,exports){
'use strict';

module.exports = footnote;

function footnote(node) {
  return '[^' + this.all(node).join('') + ']';
}

},{}],104:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');

module.exports = heading;

/* Stringify a heading.
 *
 * In `setext: true` mode and when `depth` is smaller than
 * three, creates a setext header:
 *
 *     Foo
 *     ===
 *
 * Otherwise, an ATX header is generated:
 *
 *     ### Foo
 *
 * In `closeAtx: true` mode, the header is closed with
 * hashes:
 *
 *     ### Foo ###
 */
function heading(node) {
  var self = this;
  var depth = node.depth;
  var setext = self.options.setext;
  var closeAtx = self.options.closeAtx;
  var content = self.all(node).join('');
  var prefix;

  if (setext && depth < 3) {
    return content + '\n' + repeat(depth === 1 ? '=' : '-', content.length);
  }

  prefix = repeat('#', node.depth);

  return prefix + ' ' + content + (closeAtx ? ' ' + prefix : '');
}

},{"repeat-string":121}],105:[function(require,module,exports){
'use strict';

module.exports = html;

function html(node) {
  return node.value;
}

},{}],106:[function(require,module,exports){
'use strict';

var label = require('../util/label');

module.exports = imageReference;

function imageReference(node) {
  return '![' + (this.encode(node.alt, node) || '') + ']' + label(node);
}

},{"../util/label":92}],107:[function(require,module,exports){
'use strict';

var uri = require('../util/enclose-uri');
var title = require('../util/enclose-title');

module.exports = image;

/* Stringify an image.
 *
 * Is smart about enclosing `url` (see `encloseURI()`) and
 * `title` (see `encloseTitle()`).
 *
 *    ![foo](</fav icon.png> 'My "favourite" icon')
 *
 * Supports named entities in `url`, `alt`, and `title`
 * when in `settings.encode` mode.
 */
function image(node) {
  var self = this;
  var content = uri(self.encode(node.url || '', node));
  var exit = self.enterLink();
  var alt = self.encode(self.escape(node.alt || '', node));

  exit();

  if (node.title) {
    content += ' ' + title(self.encode(node.title, node));
  }

  return '![' + alt + '](' + content + ')';
}

},{"../util/enclose-title":88,"../util/enclose-uri":89}],108:[function(require,module,exports){
'use strict';

var streak = require('longest-streak');
var repeat = require('repeat-string');

module.exports = inlineCode;

/* Stringify inline code.
 *
 * Knows about internal ticks (`\``), and ensures one more
 * tick is used to enclose the inline code:
 *
 *     ```foo ``bar`` baz```
 *
 * Even knows about inital and final ticks:
 *
 *     `` `foo ``
 *     `` foo` ``
 */
function inlineCode(node) {
  var value = node.value;
  var ticks = repeat('`', streak(value, '`') + 1);
  var start = ticks;
  var end = ticks;

  if (value.charAt(0) === '`') {
    start += ' ';
  }

  if (value.charAt(value.length - 1) === '`') {
    end = ' ' + end;
  }

  return start + value + end;
}

},{"longest-streak":21,"repeat-string":121}],109:[function(require,module,exports){
'use strict';

var copy = require('../util/copy-identifier-encoding');
var label = require('../util/label');

module.exports = linkReference;

function linkReference(node) {
  var self = this;
  var type = node.referenceType;
  var exit = self.enterLinkReference(self, node);
  var value = self.all(node).join('');

  exit();

  if (type === 'shortcut' || type === 'collapsed') {
    value = copy(value, node.identifier);
  }

  return '[' + value + ']' + label(node);
}

},{"../util/copy-identifier-encoding":87,"../util/label":92}],110:[function(require,module,exports){
'use strict';

var uri = require('../util/enclose-uri');
var title = require('../util/enclose-title');

module.exports = link;

/* Expression for a protocol:
 * http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax */
var PROTOCOL = /^[a-z][a-z+.-]+:\/?/i;

/* Stringify a link.
 *
 * When no title exists, the compiled `children` equal
 * `url`, and `url` starts with a protocol, an auto
 * link is created:
 *
 *     <http://example.com>
 *
 * Otherwise, is smart about enclosing `url` (see
 * `encloseURI()`) and `title` (see `encloseTitle()`).
 *
 *    [foo](<foo at bar dot com> 'An "example" e-mail')
 *
 * Supports named entities in the `url` and `title` when
 * in `settings.encode` mode. */
function link(node) {
  var self = this;
  var content = self.encode(node.url || '', node);
  var exit = self.enterLink();
  var escaped = self.encode(self.escape(node.url || '', node));
  var value = self.all(node).join('');

  exit();

  if (
    node.title == null &&
    PROTOCOL.test(content) &&
    (escaped === value || escaped === 'mailto:' + value)
  ) {
    /* Backslash escapes do not work in autolinks,
     * so we do not escape. */
    return uri(self.encode(node.url), true);
  }

  content = uri(content);

  if (node.title) {
    content += ' ' + title(self.encode(self.escape(node.title, node), node));
  }

  return '[' + value + '](' + content + ')';
}

},{"../util/enclose-title":88,"../util/enclose-uri":89}],111:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');
var pad = require('../util/pad');

module.exports = listItem;

/* Which checkbox to use. */
var CHECKBOX_MAP = {
  undefined: '',
  null: '',
  true: '[x] ',
  false: '[ ] '
};

/* Stringify a list item.
 *
 * Prefixes the content with a checked checkbox when
 * `checked: true`:
 *
 *     [x] foo
 *
 * Prefixes the content with an unchecked checkbox when
 * `checked: false`:
 *
 *     [ ] foo
 */
function listItem(node, parent, position, bullet) {
  var self = this;
  var style = self.options.listItemIndent;
  var loose = node.loose;
  var children = node.children;
  var length = children.length;
  var values = [];
  var index = -1;
  var value;
  var indent;
  var spacing;

  while (++index < length) {
    values[index] = self.visit(children[index], node);
  }

  value = CHECKBOX_MAP[node.checked] + values.join(loose ? '\n\n' : '\n');

  if (style === '1' || (style === 'mixed' && value.indexOf('\n') === -1)) {
    indent = bullet.length + 1;
    spacing = ' ';
  } else {
    indent = Math.ceil((bullet.length + 1) / 4) * 4;
    spacing = repeat(' ', indent - bullet.length);
  }

  value = bullet + spacing + pad(value, indent / 4).slice(indent);

  if (loose && parent.children.length - 1 !== position) {
    value += '\n';
  }

  return value;
}

},{"../util/pad":93,"repeat-string":121}],112:[function(require,module,exports){
'use strict';

module.exports = list;

/* Which method to use based on `list.ordered`. */
var ORDERED_MAP = {
  true: 'visitOrderedItems',
  false: 'visitUnorderedItems'
};

function list(node) {
  return this[ORDERED_MAP[node.ordered]](node);
}

},{}],113:[function(require,module,exports){
'use strict';

module.exports = paragraph;

function paragraph(node) {
  return this.all(node).join('');
}

},{}],114:[function(require,module,exports){
'use strict';

module.exports = root;

/* Stringify a root.
 * Adds a final newline to ensure valid POSIX files. */
function root(node) {
  return this.block(node) + '\n';
}

},{}],115:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');

module.exports = strong;

/* Stringify a `strong`.
 *
 * The marker used is configurable by `strong`, which
 * defaults to an asterisk (`'*'`) but also accepts an
 * underscore (`'_'`):
 *
 *     __foo__
 */
function strong(node) {
  var marker = repeat(this.options.strong, 2);
  return marker + this.all(node).join('') + marker;
}

},{"repeat-string":121}],116:[function(require,module,exports){
'use strict';

module.exports = tableCell;

function tableCell(node) {
  return this.all(node).join('');
}

},{}],117:[function(require,module,exports){
'use strict';

var markdownTable = require('markdown-table');

module.exports = table;

/* Stringify table.
 *
 * Creates a fenced table by default, but not in
 * `looseTable: true` mode:
 *
 *     Foo | Bar
 *     :-: | ---
 *     Baz | Qux
 *
 * NOTE: Be careful with `looseTable: true` mode, as a
 * loose table inside an indented code block on GitHub
 * renders as an actual table!
 *
 * Creates a spaced table by default, but not in
 * `spacedTable: false`:
 *
 *     |Foo|Bar|
 *     |:-:|---|
 *     |Baz|Qux|
 */
function table(node) {
  var self = this;
  var options = self.options;
  var loose = options.looseTable;
  var spaced = options.spacedTable;
  var pad = options.paddedTable;
  var stringLength = options.stringLength;
  var rows = node.children;
  var index = rows.length;
  var exit = self.enterTable();
  var result = [];
  var start;
  var end;

  while (index--) {
    result[index] = self.all(rows[index]);
  }

  exit();

  if (loose) {
    start = '';
    end = '';
  } else if (spaced) {
    start = '| ';
    end = ' |';
  } else {
    start = '|';
    end = '|';
  }

  return markdownTable(result, {
    align: node.align,
    pad: pad,
    start: start,
    end: end,
    stringLength: stringLength,
    delimiter: spaced ? ' | ' : '|'
  });
}

},{"markdown-table":23}],118:[function(require,module,exports){
'use strict';

module.exports = text;

/* Stringify text.
 * Supports named entities in `settings.encode: true` mode:
 *
 *     AT&amp;T
 *
 * Supports numbered entities in `settings.encode: numbers`
 * mode:
 *
 *     AT&#x26;T
 */
function text(node, parent) {
  return this.encode(this.escape(node.value, node, parent), node);
}

},{}],119:[function(require,module,exports){
'use strict';

var repeat = require('repeat-string');

module.exports = thematic;

/* Stringify a `thematic-break`.
 * The character used is configurable through `rule`: (`'_'`)
 *
 *     ___
 *
 * The number of repititions is defined through
 * `ruleRepetition`: (`6`)
 *
 *     ******
 *
 * Whether spaces delimit each character, is configured
 * through `ruleSpaces`: (`true`)
 *
 *     * * *
 */
function thematic() {
  var options = this.options;
  var rule = repeat(options.rule, options.ruleRepetition);
  return options.ruleSpaces ? rule.split('').join(' ') : rule;
}

},{"repeat-string":121}],120:[function(require,module,exports){
'use strict';

var unified = require('unified');
var parse = require('remark-parse');
var stringify = require('remark-stringify');

module.exports = unified().use(parse).use(stringify).freeze();

},{"remark-parse":28,"remark-stringify":76,"unified":131}],121:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],122:[function(require,module,exports){
'use strict';

var path = require('path');

function replaceExt(npath, ext) {
  if (typeof npath !== 'string') {
    return npath;
  }

  if (npath.length === 0) {
    return npath;
  }

  var nFileName = path.basename(npath, path.extname(npath)) + ext;
  return path.join(path.dirname(npath), nFileName);
}

module.exports = replaceExt;

},{"path":26}],123:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2016 Titus Wormer
 * @license MIT
 * @module state-toggle
 * @fileoverview Enter/exit a state.
 */

'use strict';

/* eslint-env commonjs */

/* Expose. */
module.exports = factory;

/**
 * Construct a state `toggler`: a function which inverses
 * `property` in context based on its current value.
 * The by `toggler` returned function restores that value.
 *
 * @param {string} key - Property to toggle.
 * @param {boolean} state - Default state.
 * @param {Object?} [ctx] - Context object.
 * @return {Function} - Enter.
 */
function factory(key, state, ctx) {
  /**
   * Enter a state.
   *
   * @return {Function} - Exit state.
   */
  return function () {
    var context = ctx || this;
    var current = context[key];

    context[key] = !state;

    /**
     * Cancel state to its value before entering.
     */
    return function () {
      context[key] = current;
    };
  };
}

},{}],124:[function(require,module,exports){
module.exports=[
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
]

},{}],125:[function(require,module,exports){
'use strict';

var entities = require('character-entities-html4');
var legacy = require('character-entities-legacy');
var hexadecimal = require('is-hexadecimal');
var alphanumerical = require('is-alphanumerical');
var dangerous = require('./dangerous.json');

/* Expose. */
module.exports = encode;

encode.escape = escape;

var own = {}.hasOwnProperty;

/* List of enforced escapes. */
var escapes = ['"', '\'', '<', '>', '&', '`'];

/* Map of characters to names. */
var characters = construct();

/* Default escapes. */
var EXPRESSION_ESCAPE = toExpression(escapes);

/* Surrogate pairs. */
var EXPRESSION_SURROGATE_PAIR = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

/* Non-ASCII characters. */
// eslint-disable-next-line no-control-regex
var EXPRESSION_BMP = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

/* Encode special characters in `value`. */
function encode(value, options) {
  var settings = options || {};
  var subset = settings.subset;
  var set = subset ? toExpression(subset) : EXPRESSION_ESCAPE;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;

  value = value.replace(set, function (char, pos, val) {
    return one(char, val.charAt(pos + 1), settings);
  });

  if (subset || escapeOnly) {
    return value;
  }

  return value
    .replace(EXPRESSION_SURROGATE_PAIR, function (pair, pos, val) {
      return toHexReference(
        ((pair.charCodeAt(0) - 0xD800) * 0x400) +
        pair.charCodeAt(1) - 0xDC00 + 0x10000,
        val.charAt(pos + 2),
        omit
      );
    })
    .replace(EXPRESSION_BMP, function (char, pos, val) {
      return one(char, val.charAt(pos + 1), settings);
    });
}

/* Shortcut to escape special characters in HTML. */
function escape(value) {
  return encode(value, {
    escapeOnly: true,
    useNamedReferences: true
  });
}

/* Encode `char` according to `options`. */
function one(char, next, options) {
  var shortest = options.useShortestReferences;
  var omit = options.omitOptionalSemicolons;
  var named;
  var numeric;

  if (
    (shortest || options.useNamedReferences) &&
    own.call(characters, char)
  ) {
    named = toNamed(characters[char], next, omit, options.attribute);
  }

  if (shortest || !named) {
    numeric = toHexReference(char.charCodeAt(0), next, omit);
  }

  if (named && (!shortest || named.length < numeric.length)) {
    return named;
  }

  return numeric;
}

/* Transform `code` into an entity. */
function toNamed(name, next, omit, attribute) {
  var value = '&' + name;

  if (
    omit &&
    own.call(legacy, name) &&
    dangerous.indexOf(name) === -1 &&
    (!attribute || (next && next !== '=' && !alphanumerical(next)))
  ) {
    return value;
  }

  return value + ';';
}

/* Transform `code` into a hexadecimal character reference. */
function toHexReference(code, next, omit) {
  var value = '&#x' + code.toString(16).toUpperCase();
  return omit && next && !hexadecimal(next) ? value : value + ';';
}

/* Create an expression for `characters`. */
function toExpression(characters) {
  return new RegExp('[' + characters.join('') + ']', 'g');
}

/* Construct the map. */
function construct() {
  var chars = {};
  var name;

  for (name in entities) {
    chars[entities[name]] = name;
  }

  return chars;
}

},{"./dangerous.json":124,"character-entities-html4":5,"character-entities-legacy":6,"is-alphanumerical":14,"is-hexadecimal":17}],126:[function(require,module,exports){
module.exports = strip;

function strip() {
  return one;
}

/* Expose modifiers for available node types.
 * Node types not listed here are not changed
 * (but their children are). */
var map = {};

map.heading = paragraph;
map.text = text;
map.inlineCode = text;
map.image = image;
map.imageReference = image;
map.break = lineBreak;

map.blockquote = children;
map.list = children;
map.listItem = children;
map.strong = children;
map.emphasis = children;
map.delete = children;
map.link = children;
map.linkReference = children;

map.code = empty;
map.horizontalRule = empty;
map.thematicBreak = empty;
map.html = empty;
map.table = empty;
map.tableCell = empty;
map.definition = empty;
map.yaml = empty;

/* One node. */
function one(node) {
  var type = node && node.type;

  if (type in map) {
    node = map[type](node);
  }

  if ('length' in node) {
    node = all(node);
  }

  if (node.children) {
    node.children = all(node.children);
  }

  return node;
}

/* Multiple nodes. */
function all(nodes) {
  var index = -1;
  var length = nodes.length;
  var result = [];
  var value;

  while (++index < length) {
    value = one(nodes[index]);

    if (value && typeof value.length === 'number') {
      result = result.concat(value.map(one));
    } else {
      result.push(value);
    }
  }

  return clean(result);
}

/* Clean nodes: merges text's. */
function clean(values) {
  var index = -1;
  var length = values.length;
  var result = [];
  var prev = null;
  var value;

  while (++index < length) {
    value = values[index];

    if (prev && 'value' in value && value.type === prev.type) {
      prev.value += value.value;
    } else {
      result.push(value);
      prev = value;
    }
  }

  return result;
}

/* Return an stringified image. */
function image(token) {
  return {
    type: 'text',
    value: token.alt || token.title || ''
  };
}

/* Return `token`s value. */
function text(token) {
  return {type: 'text', value: token.value};
}

/* Return a paragraph. */
function paragraph(token) {
  return {type: 'paragraph', children: token.children};
}

/* Return the concatenation of `token`s children. */
function children(token) {
  return token.children;
}

/* Return line break. */
function lineBreak() {
  return {type: 'text', value: '\n'};
}

/* Return nothing. */
function empty() {
  return {type: 'text', value: ''};
}

},{}],127:[function(require,module,exports){
'use strict';

module.exports = trimTrailingLines;

var line = '\n';

/* Remove final newline characters from `value`. */
function trimTrailingLines(value) {
  var val = String(value);
  var index = val.length;

  while (val.charAt(--index) === line) { /* empty */ }

  return val.slice(0, index + 1);
}

},{}],128:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],129:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = trough;

/* Methods. */
var slice = [].slice;

/* Create new middleware. */
function trough() {
  var fns = [];
  var middleware = {};

  middleware.run = run;
  middleware.use = use;

  return middleware;

  /* Run `fns`.  Last argument must be
   * a completion handler. */
  function run() {
    var index = -1;
    var input = slice.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];

    if (typeof done !== 'function') {
      throw new Error('Expected function as last argument, not ' + done);
    }

    next.apply(null, [null].concat(input));

    /* Run the next `fn`, if any. */
    function next(err) {
      var fn = fns[++index];
      var params = slice.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;

      if (err) {
        done(err);
        return;
      }

      /* Copy non-nully input into values. */
      while (++pos < length) {
        if (values[pos] === null || values[pos] === undefined) {
          values[pos] = input[pos];
        }
      }

      input = values;

      /* Next or done. */
      if (fn) {
        wrap(fn, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }

  /* Add `fn` to the list. */
  function use(fn) {
    if (typeof fn !== 'function') {
      throw new Error('Expected `fn` to be a function, not ' + fn);
    }

    fns.push(fn);

    return middleware;
  }
}

/* Wrap `fn`.  Can be sync or async; return a promise,
 * receive a completion handler, return new values and
 * errors. */
function wrap(fn, next) {
  var invoked;

  return wrapped;

  function wrapped() {
    var params = slice.call(arguments, 0);
    var callback = fn.length > params.length;
    var result;

    if (callback) {
      params.push(done);
    }

    try {
      result = fn.apply(null, params);
    } catch (err) {
      /* Well, this is quite the pickle.  `fn` received
       * a callback and invoked it (thus continuing the
       * pipeline), but later also threw an error.
       * We‚Äôre not about to restart the pipeline again,
       * so the only thing left to do is to throw the
       * thing instea. */
      if (callback && invoked) {
        throw err;
      }

      return done(err);
    }

    if (!callback) {
      if (result && typeof result.then === 'function') {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }

  /* Invoke `next`, only once. */
  function done() {
    if (!invoked) {
      invoked = true;

      next.apply(null, arguments);
    }
  }

  /* Invoke `done` with one value.
   * Tracks if an error is passed, too. */
  function then(value) {
    done(null, value);
  }
}

},{}],130:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module unherit
 * @fileoverview Create a custom constructor which can be modified
 *   without affecting the original class.
 */

'use strict';

/* Dependencies. */
var xtend = require('xtend');
var inherits = require('inherits');

/* Expose. */
module.exports = unherit;

/**
 * Create a custom constructor which can be modified
 * without affecting the original class.
 *
 * @param {Function} Super - Super-class.
 * @return {Function} - Constructor acting like `Super`,
 *   which can be modified without affecting the original
 *   class.
 */
function unherit(Super) {
  var result;
  var key;
  var value;

  inherits(Of, Super);
  inherits(From, Of);

  /* Clone values. */
  result = Of.prototype;

  for (key in result) {
    value = result[key];

    if (value && typeof value === 'object') {
      result[key] = 'concat' in value ? value.concat() : xtend(value);
    }
  }

  return Of;

  /**
   * Constructor accepting a single argument,
   * which itself is an `arguments` object.
   */
  function From(parameters) {
    return Super.apply(this, parameters);
  }

  /**
   * Constructor accepting variadic arguments.
   */
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments);
    }

    return Super.apply(this, arguments);
  }
}

},{"inherits":11,"xtend":140}],131:[function(require,module,exports){
'use strict';

/* Dependencies. */
var extend = require('extend');
var bail = require('bail');
var vfile = require('vfile');
var trough = require('trough');
var string = require('x-is-string');
var func = require('x-is-function');
var plain = require('is-plain-obj');

/* Expose a frozen processor. */
module.exports = unified().freeze();

var slice = [].slice;
var own = {}.hasOwnProperty;

/* Process pipeline. */
var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);

function pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}

function pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);

  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}

function pipelineStringify(p, ctx) {
  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}

/* Function to create the first processor. */
function unified() {
  var attachers = [];
  var transformers = trough();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;

  /* Data management. */
  processor.data = data;

  /* Lock. */
  processor.freeze = freeze;

  /* Plug-ins. */
  processor.attachers = attachers;
  processor.use = use;

  /* API. */
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;

  /* Expose. */
  return processor;

  /* Create a new processor based on the processor
   * in the current scope. */
  function processor() {
    var destination = unified();
    var length = attachers.length;
    var index = -1;

    while (++index < length) {
      destination.use.apply(null, attachers[index]);
    }

    destination.data(extend(true, {}, namespace));

    return destination;
  }

  /* Freeze: used to signal a processor that has finished
   * configuration.
   *
   * For example, take unified itself.  It‚Äôs frozen.
   * Plug-ins should not be added to it.  Rather, it should
   * be extended, by invoking it, before modifying it.
   *
   * In essence, always invoke this when exporting a
   * processor. */
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;

    if (frozen) {
      return processor;
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;

      if (options === false) {
        continue;
      }

      if (options === true) {
        values[1] = undefined;
      }

      transformer = plugin.apply(processor, values.slice(1));

      if (func(transformer)) {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Infinity;

    return processor;
  }

  /* Data management.
   * Getter / setter for processor-specific informtion. */
  function data(key, value) {
    if (string(key)) {
      /* Set `key`. */
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen);

        namespace[key] = value;

        return processor;
      }

      /* Get `key`. */
      return (own.call(namespace, key) && namespace[key]) || null;
    }

    /* Set space. */
    if (key) {
      assertUnfrozen('data', frozen);
      namespace = key;
      return processor;
    }

    /* Get space. */
    return namespace;
  }

  /* Plug-in management.
   *
   * Pass it:
   * *   an attacher and options,
   * *   a preset,
   * *   a list of presets, attachers, and arguments (list
   *     of attachers and options). */
  function use(value) {
    var settings;

    assertUnfrozen('use', frozen);

    if (value === null || value === undefined) {
      /* Empty */
    } else if (func(value)) {
      addPlugin.apply(null, arguments);
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`');
    }

    if (settings) {
      namespace.settings = extend(namespace.settings || {}, settings);
    }

    return processor;

    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = extend(settings || {}, result.settings);
      }
    }

    function add(value) {
      if (func(value)) {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`');
      }
    }

    function addList(plugins) {
      var length;
      var index;

      if (plugins === null || plugins === undefined) {
        /* Empty */
      } else if (typeof plugins === 'object' && 'length' in plugins) {
        length = plugins.length;
        index = -1;

        while (++index < length) {
          add(plugins[index]);
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`');
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin);

      if (entry) {
        if (plain(entry[1]) && plain(value)) {
          value = extend(entry[1], value);
        }

        entry[1] = value;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }

  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;

    while (++index < length) {
      entry = attachers[index];

      if (entry[0] === plugin) {
        return entry;
      }
    }
  }

  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the
   * processor. */
  function parse(doc) {
    var file = vfile(doc);
    var Parser;

    freeze();
    Parser = processor.Parser;
    assertParser('parse', Parser);

    if (newable(Parser)) {
      return new Parser(String(file), file).parse();
    }

    return Parser(String(file), file); // eslint-disable-line new-cap
  }

  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), async. */
  function run(node, file, cb) {
    assertNode(node);
    freeze();

    if (!cb && func(file)) {
      cb = file;
      file = null;
    }

    if (!cb) {
      return new Promise(executor);
    }

    executor(null, cb);

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);

      function done(err, tree, file) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file);
        }
      }
    }
  }

  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), sync. */
  function runSync(node, file) {
    var complete = false;
    var result;

    run(node, file, done);

    assertDone('runSync', 'run', complete);

    return result;

    function done(err, tree) {
      complete = true;
      bail(err);
      result = tree;
    }
  }

  /* Stringify a Unist node representation of a file
   * (in string or VFile representation) into a string
   * using the `Compiler` on the processor. */
  function stringify(node, doc) {
    var file = vfile(doc);
    var Compiler;

    freeze();
    Compiler = processor.Compiler;
    assertCompiler('stringify', Compiler);
    assertNode(node);

    if (newable(Compiler)) {
      return new Compiler(node, file).compile();
    }

    return Compiler(node, file); // eslint-disable-line new-cap
  }

  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the processor,
   * then run transforms on that node, and compile the
   * resulting node using the `Compiler` on the processor,
   * and store that result on the VFile. */
  function process(doc, cb) {
    freeze();
    assertParser('process', processor.Parser);
    assertCompiler('process', processor.Compiler);

    if (!cb) {
      return new Promise(executor);
    }

    executor(null, cb);

    function executor(resolve, reject) {
      var file = vfile(doc);

      pipeline.run(processor, {file: file}, done);

      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }

  /* Process the given document (in string or VFile
   * representation), sync. */
  function processSync(doc) {
    var complete = false;
    var file;

    freeze();
    assertParser('processSync', processor.Parser);
    assertCompiler('processSync', processor.Compiler);
    file = vfile(doc);

    process(file, done);

    assertDone('processSync', 'process', complete);

    return file;

    function done(err) {
      complete = true;
      bail(err);
    }
  }
}

/* Check if `func` is a constructor. */
function newable(value) {
  return func(value) && keys(value.prototype);
}

/* Check if `value` is an object with keys. */
function keys(value) {
  var key;
  for (key in value) {
    return true;
  }
  return false;
}

/* Assert a parser is available. */
function assertParser(name, Parser) {
  if (!func(Parser)) {
    throw new Error('Cannot `' + name + '` without `Parser`');
  }
}

/* Assert a compiler is available. */
function assertCompiler(name, Compiler) {
  if (!func(Compiler)) {
    throw new Error('Cannot `' + name + '` without `Compiler`');
  }
}

/* Assert the processor is not frozen. */
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot invoke `' + name + '` on a frozen processor.\n' +
      'Create a new processor first, by invoking it: ' +
      'use `processor()` instead of `processor`.'
    );
  }
}

/* Assert `node` is a Unist node. */
function assertNode(node) {
  if (!node || !string(node.type)) {
    throw new Error('Expected node, got `' + node + '`');
  }
}

/* Assert that `complete` is `true`. */
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');
  }
}

},{"bail":3,"extend":10,"is-plain-obj":18,"trough":129,"vfile":137,"x-is-function":138,"x-is-string":139}],132:[function(require,module,exports){
'use strict';

var iterate = require('array-iterate');

module.exports = modifierFactory;

/* Turn `callback` into a child-modifier accepting a parent.
 * See `array-iterate` for more info. */
function modifierFactory(callback) {
  return iteratorFactory(wrapperFactory(callback));
}

/* Turn `callback` into a `iterator' accepting a parent. */
function iteratorFactory(callback) {
  return iterator;

  function iterator(parent) {
    var children = parent && parent.children;

    if (!children) {
      throw new Error('Missing children in `parent` for `modifier`');
    }

    return iterate(children, callback, parent);
  }
}

/* Pass the context as the third argument to `callback`. */
function wrapperFactory(callback) {
  return wrapper;

  function wrapper(value, index) {
    return callback(value, index, this);
  }
}

},{"array-iterate":2}],133:[function(require,module,exports){
'use strict';

var visit = require('unist-util-visit');

module.exports = removePosition;

/* Remove `position`s from `tree`. */
function removePosition(node, force) {
  visit(node, force ? hard : soft);
  return node;
}

function hard(node) {
  delete node.position;
}

function soft(node) {
  node.position = undefined;
}

},{"unist-util-visit":135}],134:[function(require,module,exports){
'use strict';

var own = {}.hasOwnProperty;

module.exports = stringify;

function stringify(value) {
  /* Nothing. */
  if (!value || typeof value !== 'object') {
    return null;
  }

  /* Node. */
  if (own.call(value, 'position') || own.call(value, 'type')) {
    return location(value.position);
  }

  /* Location. */
  if (own.call(value, 'start') || own.call(value, 'end')) {
    return location(value);
  }

  /* Position. */
  if (own.call(value, 'line') || own.call(value, 'column')) {
    return position(value);
  }

  /* ? */
  return null;
}

function position(pos) {
  if (!pos || typeof pos !== 'object') {
    pos = {};
  }

  return index(pos.line) + ':' + index(pos.column);
}

function location(loc) {
  if (!loc || typeof loc !== 'object') {
    loc = {};
  }

  return position(loc.start) + '-' + position(loc.end);
}

function index(value) {
  return value && typeof value === 'number' ? value : 1;
}

},{}],135:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = visit;

/* Visit. */
function visit(tree, type, visitor, reverse) {
  if (typeof type === 'function') {
    reverse = visitor;
    visitor = type;
    type = null;
  }

  one(tree);

  /* Visit a single node. */
  function one(node, index, parent) {
    var result;

    index = index || (parent ? 0 : null);

    if (!type || node.type === type) {
      result = visitor(node, index, parent || null);
    }

    if (node.children && result !== false) {
      return all(node.children, node);
    }

    return result;
  }

  /* Visit children in `parent`. */
  function all(children, parent) {
    var step = reverse ? -1 : 1;
    var max = children.length;
    var min = -1;
    var index = (reverse ? max : min) + step;
    var child;

    while (index > min && index < max) {
      child = children[index];

      if (child && one(child, index, parent) === false) {
        return false;
      }

      index += step;
    }

    return true;
  }
}

},{}],136:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = factory;

/* Factory. */
function factory(file) {
  var contents = indices(String(file));

  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  };
}

/* Factory to get the line and column-based `position` for
 * `offset` in the bound indices. */
function offsetToPositionFactory(indices) {
  return offsetToPosition;

  /* Get the line and column-based `position` for
   * `offset` in the bound indices. */
  function offsetToPosition(offset) {
    var index = -1;
    var length = indices.length;

    if (offset < 0) {
      return {};
    }

    while (++index < length) {
      if (indices[index] > offset) {
        return {
          line: index + 1,
          column: (offset - (indices[index - 1] || 0)) + 1,
          offset: offset
        };
      }
    }

    return {};
  }
}

/* Factory to get the `offset` for a line and column-based
 * `position` in the bound indices. */
function positionToOffsetFactory(indices) {
  return positionToOffset;

  /* Get the `offset` for a line and column-based
   * `position` in the bound indices. */
  function positionToOffset(position) {
    var line = position && position.line;
    var column = position && position.column;

    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
      return ((indices[line - 2] || 0) + column - 1) || 0;
    }

    return -1;
  }
}

/* Get indices of line-breaks in `value`. */
function indices(value) {
  var result = [];
  var index = value.indexOf('\n');

  while (index !== -1) {
    result.push(index + 1);
    index = value.indexOf('\n', index + 1);
  }

  result.push(value.length + 1);

  return result;
}

},{}],137:[function(require,module,exports){
(function (process){
'use strict';

var path = require('path');
var replace = require('replace-ext');
var stringify = require('unist-util-stringify-position');
var buffer = require('is-buffer');

module.exports = VFile;

var own = {}.hasOwnProperty;
var proto = VFile.prototype;

proto.toString = toString;
proto.message = message;
proto.info = info;
proto.fail = fail;

/* Slight backwards compatibility.  Remove in the future. */
proto.warn = message;

/* Order of setting (least specific to most), we need this because
 * otherwise `{stem: 'a', path: '~/b.js'}` would throw, as a path
 * is needed before a stem can be set. */
var order = [
  'history',
  'path',
  'basename',
  'stem',
  'extname',
  'dirname'
];

/* Construct a new file. */
function VFile(options) {
  var prop;
  var index;
  var length;

  if (!options) {
    options = {};
  } else if (typeof options === 'string' || buffer(options)) {
    options = {contents: options};
  } else if ('message' in options && 'messages' in options) {
    return options;
  }

  if (!(this instanceof VFile)) {
    return new VFile(options);
  }

  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();

  /* Set path related properties in the correct order. */
  index = -1;
  length = order.length;

  while (++index < length) {
    prop = order[index];

    if (own.call(options, prop)) {
      this[prop] = options[prop];
    }
  }

  /* Set non-path related properties. */
  for (prop in options) {
    if (order.indexOf(prop) === -1) {
      this[prop] = options[prop];
    }
  }
}

/* Access full path (`~/index.min.js`). */
Object.defineProperty(proto, 'path', {
  get: function () {
    return this.history[this.history.length - 1];
  },
  set: function (path) {
    assertNonEmpty(path, 'path');

    if (path !== this.path) {
      this.history.push(path);
    }
  }
});

/* Access parent path (`~`). */
Object.defineProperty(proto, 'dirname', {
  get: function () {
    return typeof this.path === 'string' ? path.dirname(this.path) : undefined;
  },
  set: function (dirname) {
    assertPath(this.path, 'dirname');
    this.path = path.join(dirname || '', this.basename);
  }
});

/* Access basename (`index.min.js`). */
Object.defineProperty(proto, 'basename', {
  get: function () {
    return typeof this.path === 'string' ? path.basename(this.path) : undefined;
  },
  set: function (basename) {
    assertNonEmpty(basename, 'basename');
    assertPart(basename, 'basename');
    this.path = path.join(this.dirname || '', basename);
  }
});

/* Access extname (`.js`). */
Object.defineProperty(proto, 'extname', {
  get: function () {
    return typeof this.path === 'string' ? path.extname(this.path) : undefined;
  },
  set: function (extname) {
    var ext = extname || '';

    assertPart(ext, 'extname');
    assertPath(this.path, 'extname');

    if (ext) {
      if (ext.charAt(0) !== '.') {
        throw new Error('`extname` must start with `.`');
      }

      if (ext.indexOf('.', 1) !== -1) {
        throw new Error('`extname` cannot contain multiple dots');
      }
    }

    this.path = replace(this.path, ext);
  }
});

/* Access stem (`index.min`). */
Object.defineProperty(proto, 'stem', {
  get: function () {
    return typeof this.path === 'string' ? path.basename(this.path, this.extname) : undefined;
  },
  set: function (stem) {
    assertNonEmpty(stem, 'stem');
    assertPart(stem, 'stem');
    this.path = path.join(this.dirname || '', stem + (this.extname || ''));
  }
});

/* Get the value of the file. */
function toString(encoding) {
  var value = this.contents || '';
  return buffer(value) ? value.toString(encoding) : String(value);
}

/* Create a message with `reason` at `position`.
 * When an error is passed in as `reason`, copies the stack. */
function message(reason, position, ruleId) {
  var filePath = this.path;
  var range = stringify(position) || '1:1';
  var location;
  var err;

  location = {
    start: {line: null, column: null},
    end: {line: null, column: null}
  };

  if (position && position.position) {
    position = position.position;
  }

  if (position) {
    /* Location. */
    if (position.start) {
      location = position;
      position = position.start;
    } else {
      /* Position. */
      location.start = position;
    }
  }

  err = new VMessage(reason.message || reason);

  err.name = (filePath ? filePath + ':' : '') + range;
  err.file = filePath || '';
  err.reason = reason.message || reason;
  err.line = position ? position.line : null;
  err.column = position ? position.column : null;
  err.location = location;
  err.ruleId = ruleId || null;
  err.source = null;
  err.fatal = false;

  if (reason.stack) {
    err.stack = reason.stack;
  }

  this.messages.push(err);

  return err;
}

/* Fail. Creates a vmessage, associates it with the file,
 * and throws it. */
function fail() {
  var message = this.message.apply(this, arguments);

  message.fatal = true;

  throw message;
}

/* Info. Creates a vmessage, associates it with the file,
 * and marks the fatality as null. */
function info() {
  var message = this.message.apply(this, arguments);

  message.fatal = null;

  return message;
}

/* Inherit from `Error#`. */
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype;
VMessage.prototype = new VMessagePrototype();

/* Message properties. */
proto = VMessage.prototype;

proto.file = '';
proto.name = '';
proto.reason = '';
proto.message = '';
proto.stack = '';
proto.fatal = null;
proto.column = null;
proto.line = null;

/* Construct a new file message.
 *
 * Note: We cannot invoke `Error` on the created context,
 * as that adds readonly `line` and `column` attributes on
 * Safari 9, thus throwing and failing the data. */
function VMessage(reason) {
  this.message = reason;
}

/* Assert that `part` is not a path (i.e., does
 * not contain `path.sep`). */
function assertPart(part, name) {
  if (part.indexOf(path.sep) !== -1) {
    throw new Error('`' + name + '` cannot be a path: did not expect `' + path.sep + '`');
  }
}

/* Assert that `part` is not empty. */
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty');
  }
}

/* Assert `path` exists. */
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too');
  }
}

}).call(this,require('_process'))
},{"_process":27,"is-buffer":15,"path":26,"replace-ext":122,"unist-util-stringify-position":134}],138:[function(require,module,exports){
module.exports = function isFunction (fn) {
  return Object.prototype.toString.call(fn) === '[object Function]'
}

},{}],139:[function(require,module,exports){
var toString = Object.prototype.toString

module.exports = isString

function isString(obj) {
    return toString.call(obj) === "[object String]"
}

},{}],140:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[1]);
